<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>更专注一些</title>
    <link href="/%E6%95%B0%E5%AD%97%E5%8C%96/99ef44486532.html"/>
    <url>/%E6%95%B0%E5%AD%97%E5%8C%96/99ef44486532.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2025年悄然而至，脑子里其实想了很多25年想做的事情，包括花时间陪家人，花时间学技术，花时间学团队管理，花时间写文章。想做的事情太多，时间、精力都无暇顾及，最后的最后，好像每年收场都是一事无成的样子。</p><p><strong>似乎哪一年都是怀揣着梦想的种子出发，然后年底颗粒无收。</strong></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实思考了几天，最后得出的结论是，不够专注。没有认清楚目标，没有发掘自己的长处，想着四处开花的场景，其实这针对个人来说，是做不到的。</p><p>所以呢，25年甚至以后的生涯中，生活中和职业中，注重<strong>聚焦、专注</strong>。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>生活上，花时间陪家人，做一个温柔的人（不展开详述，目前做得还可以。）；</p><p>工作上，专注团队管理和制造业数字化。</p><p>工作中一直在管理团队，只是一直缺乏理论的指导，这块需要加强，也一直在学习与考证，<strong>25年希望理论和实践相结合，团队管理能力更上一层楼。</strong></p><p>制造业数字化，也是在行业内从业3年，虽然时间不算长，但是穿梭于各个厂房，有一些业务和技术的积累沉淀，加以思考和提炼，整理出体系化的知识结构，并进行文章的输出。</p><p>以上，祝好。</p>]]></content>
    
    
    <categories>
      
      <category>数字化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>及时处理还是非及时处理</title>
    <link href="/%E7%BC%96%E7%A8%8B/c22f453bbbe3.html"/>
    <url>/%E7%BC%96%E7%A8%8B/c22f453bbbe3.html</url>
    
    <content type="html"><![CDATA[<p>在编写业务代码的时候，常规性的是<strong>及时处理</strong>业务逻辑，因为写代码一般是串行的，先做什么事，再做什么事，但是有时候为了业务接耦等原因，也会用到非及时处理的方式，比如常用的多线程，消息队列，定时任务都属于<strong>非及时处理</strong>。</p><p>用及时处理，还是非及时处理，应该从哪些方面思考呢？</p><p>第一思考方面是<strong>业务</strong>，其次是<strong>扩展性</strong>和<strong>容错性</strong>。</p><p>举几个最近遇到业务场景，思考下应该要用什么处理方式。</p><p><strong>场景1：</strong>做用户行为统计功能，设计的系统中有页面基础信息表需要维护，页面基础信息表包含页面标题、页面路径字段，前端工程师埋点上报的数据中包含页面标题和页面路径。</p><p>方案1（及时处理）：每次在上报埋点行为数据的时候进行保存，由于基础信息只需要保存一次，所以需要在保存之前判断页面基础信息是否存在；</p><p>方案2（非及时处理）：保存的地方不做基础信息保存的处理，单独启动一个定时任务，定时扫描最近5分钟上报的页面是否存在于基础信息表中，批量进行基础信息处理。</p><p>从业务出发，会选择方案2，因为统计数据对实时性要求没有那么高，而且代码业务也实现了解耦。</p><p><strong>场景2：</strong>根据制成品数量来完工订单的逻辑，比如某个订单需要制作某个产品（制成品）100件，应该怎么样控制订单状态？</p><p>方案1（及时处理）：每个制成品完工的时候与订单数量对比，如果达到订单数量，进行订单完工订单处理；</p><p>方案2（非及时处理）：制成品完工不做处理，单独启动一个定时任务进行扫描，如果到达指定数量，进行订单完工；</p><p>从业务出发，会选择方案1，因为订单完工状态必须及时更新，以便下一个订单及时开始。</p><p>先从业务出发，想清楚大方向是采用及时处理还是非及时处理，然后再基于处理方案选择中间件，进行架构。</p><p>好的架构中，<strong>剖析业务是首要任务</strong>，然后兼顾<strong>扩展性</strong>和<strong>容错性</strong>，后期将会节约很多运营工作和重构工作。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慎用非结构化数据</title>
    <link href="/%E7%BC%96%E7%A8%8B/e36826130851.html"/>
    <url>/%E7%BC%96%E7%A8%8B/e36826130851.html</url>
    
    <content type="html"><![CDATA[<p>在nosql、json、map满天飞的年代，我还是喜欢用<strong>实体类包装的结构化数据，因为实体类结构化数据编码方式总会给我一种踏实感</strong>。</p><p>文章中讲的结构化数据，指关系型数据库的每一行数据、编码中的实体类。</p><p>在日常工作中，开发业务代码者应该还是居多，也有一些少数是开发功能性的中间件。</p><p>开发业务代码，应该在业务功能实现的同时，还需要特别注意<strong>代码的可读性</strong>和<strong>功能的扩展性</strong>。</p><p>这其中有一条铁律，即<strong>慎用非结构化数据</strong>，包括但不限于map、json。</p><p>刚参加工作那会儿，在电商公司负责营销板块银行卡支付打折活动。</p><p>业务场景是这样子的，使用工行卡支付，打9.8折，使用中行卡支付，打9.9折，在预见的将来又会有建行卡9.5折这类型的营销活动。</p><p>如果是你来负责，你在设计思考的时候，会思考哪些方面呢？</p><p>当时的实现方式是直接把营销活动信息（活动类型、折扣率、支付推荐语…）序列化存入数据库当中，当时还沾沾自喜的想着，我这个扩展变更很灵活，需要增加新功能的时候，不需要进行数据库的字段变更，但是牺牲了<strong>数据库层面的可读性</strong>，后来经常因为<strong>反序列化key不存在</strong>出过几次生产事故，大致是以为反序列化后存在某个key，实际又没有该key，迫不得已只能在代码上对反序列化结果做格式判断，从而导致非业务代码增加，又降低了<strong>代码层面的可读性</strong>。实现方式还有一个弊端，非常<strong>不利于功能扩展</strong>，营销活动信息会逐步增加，新版本扩展了新的序列化字段，在新版本上线的时候，对原来的数据，需要进行初始化，增加了运维成本，如果没有考虑初始化，到又会出现上面<strong>反序列化key不存在</strong>的问题。</p><p>上面是一个很好的反面例子，在设计思考的阶段，只考虑了业务功能的实现，没有充分考虑<strong>可读性</strong>与<strong>扩展性</strong>。</p><p>根据我的理解，把可读性从优到良分为4个层次：</p><p>**1.代码可读，数据可读    **</p><p>**2.代码可读，数据不可读    **</p><p>**3.数据可读，代码不可读    **</p><p><strong>4.代码不可读，数据不可读</strong></p><p>最近团队重新做质量追溯的功能板块，复盘去年设计一个追溯数据存储方案，又犯了类似的错误。</p><p>使用了非结构化数据Map（可以理解为MySQL的json格式）结构进行了数据存储。</p><p>犯了考虑问题不全面的错误，只考虑了功能的实现，没有考虑数据后期的<strong>可读性</strong>与<strong>维护性</strong>。最后导致采集的数据根本没法用。</p><p>现在复盘一下，我们采集数据应该自顶向下的来进行思考，思考采集数据的目的是什么？</p><p>是为了把数据采集上来存进数据库？还是为了真正的把数据分文别类的存储起来，然后把数据利用起来？当然是后者，我们当时连采集数据的结构都没有定义清楚，尽想着功能的灵活性了，后来纯粹的把事情做成了前者。</p><p>在v2.0的版本上，<strong>强调要使用结构化进行存储，没有把结构思考清楚，不进行数据存储。</strong></p><p><strong>重点要把输入和输出的数据结构定义好，将来优化逻辑，重写可控，测试也可控，反之则根本不敢动手，因为非结构化的数据扩散至项目的各处，不能评估其影响范围。</strong></p><p>不要写太“灵活”的代码，灵活就是给垃圾代码、垃圾数据提供给有利的生长环境，让代码看上去“呆”一点，一段代码只处理一个业务，就算几个业务之间有逻辑重复的地方，复制粘贴重复的代码也是可取的，一切从业务出发，业务是独立的，代码就应该是独立的，应该由业务定义代码，而不是代码来定义业务，因为业务现阶段看似一样，将来差别可能会很大。</p><p>一个好的架构中，<strong>可读性</strong>和<strong>维护性</strong>是高于业务的实现，因为没有保护好这两点，后期将会需要投入更大的人力来进行维护功能与重构工作，而保证可读性和维护性，<strong>慎用非结构化数据是铁律</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>慎用数据字典</title>
    <link href="/%E7%BC%96%E7%A8%8B/501bcdfdbadb.html"/>
    <url>/%E7%BC%96%E7%A8%8B/501bcdfdbadb.html</url>
    
    <content type="html"><![CDATA[<p>还是那个陈年老项目，在熟悉一个新模块，看到一些代码，记录一下。</p><p>编程中使用数据字典是很常见的，有时候使用它为了图方便能够造成滥用，最常见的的场景就是在数据库的数据字典里面配置某种个类型，然后在某种类型下面维护很多值，又在代码中强依赖它来写业务逻辑处理，这对代码的可读性是不友好的。</p><p>比如：在字典里面配置了“设备类型”这种类型字典，然后有值列表，设备类型包含1、2、3 …（或者稍微友好一些使用code = device_type_mac），然后在代码中根据设备类型做对应的业务处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(deviceType == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 针对设备类型1，做对应的业务处理  </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(deviceType == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-comment">// 针对设备类型2，做对应的业务处理  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样子会导致2个问题：</p><ol><li>需要跨工具职能去了解业务，假设了解某个设备做了哪些业务处理，总是往返于代码和数据当中，可能还因为数据的缺失导致对业务理解的断层，有点像我们数据库的存储过程和触发器这些工具的缺点，它的出发点是好的，是为了方便我们更方便的维护数据，但是它对我们代码的可读性也是不友好的，<strong>总要从代码和数据两个方面结合才能看到业务的整体</strong> 。</li><li>某天系统迁移到新的场景，有新的设备类型，可能由于我的设备类型没有正确配置，导致业务逻辑漏未做处理，会出现那种不是很明显，但是很重要的逻辑被疏漏，而且不容易排查。</li></ol><p>解决的方式，我推荐尽量用<strong>枚举</strong>来实现对应的功能，因为这种针对性业务处理它的<strong>枚举值是有限的</strong>，它能从引用关系就能看到整体业务的全貌，如果迁移到新的场景，它能显现的告诉阅读人员怎样去扩展。具体实现对应的业务处理可以结合<strong>策略模式</strong>优雅的扩展。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程的这几个习惯要不得</title>
    <link href="/%E7%BC%96%E7%A8%8B/5b04bba780ac.html"/>
    <url>/%E7%BC%96%E7%A8%8B/5b04bba780ac.html</url>
    
    <content type="html"><![CDATA[<p>最近有幸接手到一个成年老项目，看到一些问题，整理一下。</p><h3 id="不要使用Map作为返回值"><a href="#不要使用Map作为返回值" class="headerlink" title="不要使用Map作为返回值"></a>不要使用Map作为返回值</h3><p>强烈呼吁不要使用Map作为返回值，它的唯一好处是开发速度快，但是因为那一点点的开发速度，降低代码的可读性、可维护性，是非常不划算的。</p><p>他会导致几个问题，新人接手不能从返回值中了解到业务，而是要一层一层的跟进到SQL层面；还有就是如果数据库值为null，返回的Map中又无对于的key，前端同学就会很纳闷，怎么每条数据返回的数据结构都不一致。</p><h3 id="不要在SQL里面处理业务逻辑"><a href="#不要在SQL里面处理业务逻辑" class="headerlink" title="不要在SQL里面处理业务逻辑"></a>不要在SQL里面处理业务逻辑</h3><p>最近修改一个迭代近10年的老项目，由于迭代时间久，业务功能很丰富，这次需要重启一个业务模块，由于无文档，业务配置项不知道入口在哪里，所以只能从代码里面查找对应功能，看到了该模块很多几屏都放不下的SQL，SQL里面有各种子查询、三元运算符，看得人是眼花缭乱，基本所有的业务，都揉杂在SQL里面了，调试也无从下手，也无备注。</p><p>为了方便后续人员进行问题排查和了解业务，不要在SQL里面处理业务，可读性差，不方便业务功能调试，正确的方式应该是利用代码来处理业务逻辑。</p><h3 id="从工具职能上来解决问题"><a href="#从工具职能上来解决问题" class="headerlink" title="从工具职能上来解决问题"></a>从工具职能上来解决问题</h3><p>看到很多代码，总喜欢跨职能来解决问题，数据库有脏数据问题，正确的方式应该是找到脏数据产生的根因并进行生产数据修复；错误的方式就是在使用数据的时候，去处理数据，比如说从业务出发某记录数应该是不重复的，但是在使用的时候发现了重复数据，立即写代码来处理该重复数据问题。</p><p>数据问题，就应该从数据上去处理好，找到根因，处理好脏数据。而不是本来是数据的工作，错误的利用代码来写逻辑处理。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>最近在工作中有两点感悟，一是简单的编程规则很容易掌握，但是让一个团队在工作中好好的运用这些规则，又会很难。二是把简单的、常识性的知识点运用到实际工作中，就已经胜过了80%的人。</p><p>技能型的知识学习是为了运用，而不是为了徒增理论知识，先把简单的知识运用到工作中，然后再去琢磨新技术、新语法吧。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组织架构调整</title>
    <link href="/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/bf10de68d33d.html"/>
    <url>/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/bf10de68d33d.html</url>
    
    <content type="html"><![CDATA[<ol><li>找到团队中短板，并果断对该部门管理者进行移除；</li><li>利用换位思考思维，把需要彼此合作的部门管理者进行对调，彼此熟悉对方的工作流程来进行沟通合作；</li><li>政策上予以大力支持，积极反馈问题、组织迭代；</li><li>团队管理的几个大点：<strong>信任、沟通、反馈、迭代</strong>。</li></ol>]]></content>
    
    
    <categories>
      
      <category>团队管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精益制造中的 OEE：目标、评估方法和六大损失</title>
    <link href="/%E6%95%B0%E5%AD%97%E5%8C%96/3bee08a3c6ef.html"/>
    <url>/%E6%95%B0%E5%AD%97%E5%8C%96/3bee08a3c6ef.html</url>
    
    <content type="html"><![CDATA[<p>OEE 是设备综合效率 (Overall Equipment Effectiveness) 的缩写，是精益管理实践的重要组成部分。该指标被制造企业广泛采用，是衡量生产效率的公认标准和基准。OEE 最初由日本设备维修协会开发，是一种用于评估制造设施的技术和组织维度的综合工具。</p><h2 id="OEE-的目标"><a href="#OEE-的目标" class="headerlink" title="OEE 的目标"></a>OEE 的目标</h2><p>OEE 的核心是全面客观地反映生产环境中生产效率的现状。这使得企业能够深入了解他们的设备和流程运行是否接近其最大潜能。通过综合考虑设备的可用率、性能效率和生产质量等因素，OEE 能够呈现制造过程的总体效率。</p><p>OEE 的强大之处在于它能够系统地揭示改进空间。通过分析影响 OEE 的各个因素（包括停机、速度损失和缺陷），可以找出瓶颈、低效和需要改进的地方。这种基于数据的方法让企业能够在流程优化和资源分配方面做出明智的决策。</p><p>OEE 还是持续改进的指南针。通过不断地监测和提升 OEE，制造企业可以保障他们的经济绩效持续向好。OEE 不仅能反映当前的生产效率，还有助于制定合理的性能目标，并随着时间的推移评估各种改进措施的效果。</p><h2 id="如何计算-OEE"><a href="#如何计算-OEE" class="headerlink" title="如何计算 OEE"></a>如何计算 OEE</h2><p>OEE 反映了有效生产时间占计划生产时间的比例。它的计算基于三个因素：可用率、性能和质量。</p><ol><li>可用率旨在消除中断，保证平稳运行。</li><li>质量注重完美，目标是减少缺陷产品。</li><li>性能旨在防止速度下降，保持高效率。</li></ol><p>OEE 可以用以下公式计算，其中可用率、性能和质量是制造领域的重要指标。</p><p><strong>OEE = 可用率 x 性能 x 质量</strong></p><h3 id="可用率"><a href="#可用率" class="headerlink" title="可用率"></a>可用率</h3><p>可用率反映了机器实际运行时间占计划运行时间的比例，以百分比表示。计算可用率的方法是，将实际运行时间除以计划运行时间，再乘以 100 得到百分比。</p><p><strong>可用率 = 实际运行时间 / 计划运行时间</strong></p><p>机器的计划运行时间可以从生产计划中获取。要获得实际运行时间，需要从计划运行时间中扣除所有停机时间。通过分析停机数据，不仅可以揭示停机的原因，还可以发现潜在的改进机会。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>要确定性能，需要将实际产量与机器在最高运行速度下有效时间内的最大产量进行比较。</p><p><strong>性能 = 实际性能 / 目标性能</strong></p><p>实际性能是通过计算包括废品在内的全部产量来确定的。而目标性能则是根据机器每小时的最大产量与实际运行时间相乘来计算的，目标性能反映了在该时间段内的潜在生产能力。</p><h3 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h3><p>质量是 OEE 必须计算的第三个要素。它是符合质量标准的合格产品在总产品中所占的比例。</p><p><strong>质量 = 合格产品 / 总产品</strong></p><p>在实际操作中，要计算合格产品的数量，通常是从给定时间段内生产的总产品数量中减去废品和返工产品的数量。这个公式表明，总产品的数量等于合格产品、废品和返工产品的数量之和。</p><h2 id="OEE-性能评分"><a href="#OEE-性能评分" class="headerlink" title="OEE 性能评分"></a>OEE 性能评分</h2><p>如果可用率、性能和质量没有受到任何影响，就可以实现 100% 的完美 OEE。这意味着在没有中断的情况下，以最高速度生产出全部合格的产品。在实际生产中达到这一理论分数通常不太可能，OEE 分数超过 80% 就可以视为非常出色的表现。大多数制造企业的运营水平通常在 60% 到 80% 的 OEE 范围内。当 OEE 低于 60% 时，意味着工厂存在严重问题，这一水平的分数可以视为警告信号，表明存在巨大的改进空间。</p><ul><li>80% - 100% 为优秀 - 在实际中难以实现</li><li>60% - 80% 为良好 - 大部分制造企业的水平</li><li>60% 或以下为表现不佳 - 有很大的提升空间</li></ul><h2 id="六大损失"><a href="#六大损失" class="headerlink" title="六大损失"></a>六大损失</h2><p>OEE 的主要目标是减少或消除所谓的六大损失 (Six Big Losses)。它们是造成生产过程中与设备相关的生产效率损失的主要因素。</p><p><img src="https://mkstatic.lianbian.net/202406042135572.png" alt="六大损失"></p><h3 id="可用率损失"><a href="#可用率损失" class="headerlink" title="可用率损失"></a>可用率损失</h3><p>OEE 的一个基本要素是机器和系统的可用率。正常运行时间是指机器或系统正常运行并进行生产的时间。相反，停机时间是指机器本应运行但却无法运行，从而造成经济损失的时间。</p><ol><li><p>计划内停机</p><p>导致机器停机的计划内事件会降低 OEE。这些事件包括更换、维护、检查和清洁等。通过使用专业的软件，可以对这些计划内停机进行细致的分析和优化，以尽量减少它们的影响，尽管它们具有非负面性质，但仍有很大的改进空间。</p></li><li><p>计划外停机</p><p>当计划内的生产因故障、宕机、停电、自然灾害或缺勤等意外事件而中断时，就称为计划外停机。为了减少这些无效时间，需要准确地追踪原因，进行数字化分类和持续分析，以找出流程中的薄弱环节。</p></li></ol><h3 id="性能损失"><a href="#性能损失" class="headerlink" title="性能损失"></a>性能损失</h3><p>OEE 的另一个重要要素是机器和系统的性能。这是指在规定的运行时间内，实际生产的产量与理论上能够生产的最大产量的比例。短暂中断或过慢的运行速度都可能导致性能损失。</p><ol><li><p>短暂停</p><p>不到一分钟的短暂停是由工具问题、编程错误、传感器拥塞或需要快速清理等原因引起的，通常由操作员解决。这些中断虽然不引人注意，但却会累积数分钟的非生产时间。短暂停是可以预测并能够消除或控制的。</p></li><li><p>慢周期</p><p>当机器因为机龄、维护、故障或材料等因素导致运行速度低于其潜在最高速度时，就会造成损失。与短暂停不同，慢周期情况下生产仍在继续，但以较慢的速度进行。如果无法确定理想的运行时间，管理层可以依据历史数据来确定这些时间，而进行充分研究是确定它们的关键。</p></li></ol><h3 id="质量损失"><a href="#质量损失" class="headerlink" title="质量损失"></a>质量损失</h3><p>在 OEE 中，质量损失是指产品质量与预期标准不符。与其他两种损失相比，质量损失的影响要大得多。这是因为缺陷产品不仅浪费了材料，还浪费了生产时间。</p><p>即使有缺陷的产品可以修复，返工也要占用操作员和机器资源，因此也属于损失。</p><ol><li><p>生产型废品</p><p>有些问题必须进行生产后才能发现，例如过度包装、包装不足、标签错误或包装有缺陷。传感器或摄像头等技术手段可以实时识别质量问题，从而大大缓解这些问题。配合专业的 OEE 软件，这种类型的损失有望在不久的将来消除。</p></li><li><p>启动型废品</p><p>当机器在启动、设置变更或产品调整过程中因不稳定而产生次品时，就会出现这种损失。操作员的专业技能在正确设定和避免反复试错方面至关重要。自动化数字辅助系统可快速显著地减少这种类型的损失。</p></li></ol><h2 id="OEE-的不足之处"><a href="#OEE-的不足之处" class="headerlink" title="OEE 的不足之处"></a>OEE 的不足之处</h2><p>随着智能制造领域的不断发展，人们越来越清楚地认识到，仅仅依靠 OEE 可能无法全面反映企业在智能制造方面的成就。对智能制造的评估不应只局限于 OEE，企业应该有更广阔的视野，以鼓励持续的发展和创新。</p><p>OEE 的不足主要体现在：</p><ul><li><strong>缺乏供应链指标</strong> - OEE 虽然可以提高单个机器的效率，但却忽略了制造过程与供应链系统的紧密整合。</li><li><strong>忽视人力因素</strong> - 技术熟练、积极主动的员工对于完善生产流程和提高生产效率有着重要影响。OEE 并没有涵盖这些因素。</li><li><strong>忽视环境因素</strong> - 可持续性对制造商来说至关重要，制造商应该考虑其运营对环境的影响。OEE 没有考虑资源利用、能源节约或废弃物减少等方面。</li></ul><p>为了有效地分析智能制造计划、评估原材料准备、了解员工技能、以及推动可持续性发展，制造商应该采用更全面的 KPI。</p><h2 id="使用-OMH-计算-OEE"><a href="#使用-OMH-计算-OEE" class="headerlink" title="使用 OMH 计算 OEE"></a>使用 OMH 计算 OEE</h2><p>EMQ 提出的 <a href="https://www.emqx.com/zh/blog/open-manufacturing-hub-a-reference-architecture-for-industrial-iot">Open Manufacturing Hub（OMH）</a>解决方案为制造业的运营带来了 OEE 的显著提升，例如，通过实时监测和数据集成可立即洞察设备性能并进行准确的 OEE 计算。它采用预测性维护算法来防止意外停机，简化报告流程，借助历史数据和分析支持持续改进活动。此外，OMH 还通过优化资源分配、实现远程监测来提高设备的整体效率和生产性能，从而改善 OEE 指标。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总之，OEE 通过对生产效率进行全面评估，在精益管理中发挥着重要的作用。OEE 能够提供客观的洞察、揭示改进的机会、指导决策并支持持续的改进，是提高制造运营整体效率和成功率的基石。</p><p>转载： <a href="https://www.emqx.com/zh/blog/oee-in-lean-manufacturing">https://www.emqx.com/zh/blog/oee-in-lean-manufacturing</a></p><p><strong>找到解决问题的标准方法，理解它，吃透它，并坚定执行。</strong></p>]]></content>
    
    
    <categories>
      
      <category>数字化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>影响工作效率的毒药</title>
    <link href="/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/29492d551518.html"/>
    <url>/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/29492d551518.html</url>
    
    <content type="html"><![CDATA[<p><strong>自证的怪圈</strong></p><p>可能会因为领导的一句话，他连自己都没弄清楚要做什么事情，就来跟你传达需求，最后你必须跟一群人非专业人士去证明专业问题无问题，而进入<strong>自证的怪圈</strong>。</p><p><strong>不懂就问</strong></p><p>这是不提倡的，不思考就去问。</p><p><strong>指望重构解决问题</strong></p><p><strong>一问即发</strong></p><p>不问没问题，感觉进度正常，一问被反馈一堆问题。</p><p><strong>结论后置</strong></p><p>开会无主题，讨论（会议）后无结论。</p><p>以上几点，不但影响自己的工作效率，还影响整个团度的效率，要及时清理这些影响工作效率的毒药。</p>]]></content>
    
    
    <categories>
      
      <category>团队管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字化怎么落地</title>
    <link href="/%E6%95%B0%E5%AD%97%E5%8C%96/cab77904550d.html"/>
    <url>/%E6%95%B0%E5%AD%97%E5%8C%96/cab77904550d.html</url>
    
    <content type="html"><![CDATA[<p>昨天与好友小聚，碰撞了一些想法，结合之前的一些零散的记录，整理一下关于<strong>数字化</strong>怎么落地的闲篇。</p><ol><li><p>数字化转型没有标准解决方案</p></li><li><p>技术不值钱，业务其次，重要的是市场订单</p></li><li><p>在没有订单前，抽取出<strong>标准化</strong>的板块进行打磨</p></li><li><p>订单 -&gt; <strong>中间商（渠道）</strong>-&gt; 市场，要注意寻找自己的“中间商”，也可以说是给你背书的人与企业</p></li><li><p>不要觉得自己的产品low，可能别人的产品更low，关注解决的痛点问题</p></li><li><p>最后一点就是我们的人生彼此还是落入了俗套，彼此都有经济压力</p></li></ol><p><em>下面是一些管理上的感受：</em></p><p><strong>以终为始，循序渐进。</strong></p><p>蓝图倒推实现步骤，多场景模拟（标准化场景），来订单之后加上市场来磨练产品，验证产品的正确性。</p><p><strong>标准化（业务、团队）</strong></p><p>通过理论加实践，把团队从合格锻炼至成熟，让团队成员对标准的业务有所认知，非标准的业务接受速度就会快一些，让人力成本能够复利，项目组交叉更换团队成员。</p><p><strong>监督执行</strong></p><p>只有落地了，才有价值，一切落地不了的标准化和所谓的战略，都无价值的。</p>]]></content>
    
    
    <categories>
      
      <category>数字化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数字化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年收获的关键几句话</title>
    <link href="/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/2e9f0da2cd9e.html"/>
    <url>/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/2e9f0da2cd9e.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>2023年收获的关键几句话，分享记忆一下：</p><ol><li>世界的任何事物运转需要一种规则，这个规则是你对待事情变化的标尺</li><li>任何事情都是有方法的，如果觉得凌乱了，就先停下</li><li>我们并不需要去学习很多高深的理论知识，把懂得的知识执行到位，就超过了80%的人</li></ol>]]></content>
    
    
    <categories>
      
      <category>团队管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年度总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文章分类维护文档</title>
    <link href="/%E7%BC%96%E7%A8%8B/67d69e55ec02.html"/>
    <url>/%E7%BC%96%E7%A8%8B/67d69e55ec02.html</url>
    
    <content type="html"><![CDATA[<p><code>Java</code></p><p><code>团队管理</code></p><p><code>数据库</code></p><p><code>编程</code></p><p><code>redis</code></p><p><code>数字化</code></p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>标准是迭代出来的</title>
    <link href="/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/eee227583bf1.html"/>
    <url>/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/eee227583bf1.html</url>
    
    <content type="html"><![CDATA[<p>我们要把作业环境标准化，从而间接的把问题标准化，然后解决方案就能对应的标准化，标准化之后的解决方案就能进行积累，形成整体性解决方案。</p><p>不管是管理团队，还是管理代码，都要有一个软性目标，就是有意识的去迭代适用于团队的标准，这个标准可能是我们的物料、规则、程序模版 …</p><p>我们为什么需要做标准？</p><ol><li><strong>方便定义与解决问题</strong></li></ol><p>当遇到一个模棱两可的问题，可以去寻找行业标准的解决方案，能够把问题定义清楚，并从哪方面去解决问题。也可以团队内新定义标准，但是该标准具有代表性并进行存档，能够代表某一类问题，以便将来再遇到该类问题，能够从标准化的“库”中搜寻到解决方案。</p><ol start="2"><li><strong>方便管理问题</strong></li></ol><p>当我们一个产品研发完成，需要开发2.0版本的时候，前面积累的标准的问题的解决方案，会是一个宝藏，可以直接拿来初始化成2.0产品的初代标准执行文件，迭代出2.0适用的标准，如此迭代，能够达到<strong>继承</strong>的价值。</p><p><strong>标准化的核心是降本（人力、财力、时间），从而使产品、团队有竞争力，不管是研发产品，还是管理团队，都是这个核心。</strong></p>]]></content>
    
    
    <categories>
      
      <category>团队管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件系统稳定的策略</title>
    <link href="/%E7%BC%96%E7%A8%8B/f4d10d285dea.html"/>
    <url>/%E7%BC%96%E7%A8%8B/f4d10d285dea.html</url>
    
    <content type="html"><![CDATA[<p>记录一些最近发生的系统问题，以及制定的解决策略。</p><h3 id="场景1"><a href="#场景1" class="headerlink" title="场景1"></a>场景1</h3><p>关键同事请假，开发工作和运维工作无法正常运行。</p><p><strong>问题：</strong>项目和人的耦合度太高。</p><p><strong>策略：</strong>从业务入手，加强团队培训，设立A/B角色。</p><h3 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h3><p>慢SQL堆积，点击一个页面查询，直接把系统拖垮。</p><p><strong>问题：</strong>缺少SQL审查环节，系统没有进行隔离。</p><p><strong>策略：</strong>增加SQL审核机制，主业务系统和数控报表系统进行隔离，报表系统的查询，不影响正常的业务调度。</p><h3 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h3><p>A工程师觉得a中间件好，引入到项目，B工程师也引入他觉得好的中间件。</p><p><strong>问题：</strong>中间件混乱，实现同样功能的类似中间件重复引入，增加了维护的“黑匣子”。</p><p><strong>策略：</strong>中间件标准化，让指定部门（如基础架构部门）负责中间件的引入，同时也增加适用于所有人的中间件引入流程规范。</p><p><img src="https://mkstatic.lianbian.net/202312031107647.png" alt="时间的力量"></p><h3 id="场景4"><a href="#场景4" class="headerlink" title="场景4"></a>场景4</h3><p>系统不扛压，稍微有些数据，服务器资源占用直线上升。</p><p><strong>问题：</strong>程序员素养需要提升，提高时间复杂度和空间复杂度的技术培训。</p><p><strong>策略：</strong>在上线环节中增加压测节点，边技术培训边通过压测结果驱动系统往一个指定的性能指标看齐。</p><h3 id="场景5"><a href="#场景5" class="headerlink" title="场景5"></a>场景5</h3><p>系统不稳定，发版本总有会有些小问题。</p><p><strong>问题：</strong>代码质量考虑不周全，而工业对软件的稳定要求极高。</p><p><strong>策略：</strong>增加测试环节，把稳定的、公用的板块进行抽离（如与设备打交道的板块），增加代码review机制。</p><h3 id="场景6"><a href="#场景6" class="headerlink" title="场景6"></a>场景6</h3><p>客户反馈挂了，我们才知道系统挂了。</p><p><strong>问题：</strong>业务是否正常提供服务，监控不及时。</p><p><strong>策略：</strong>增加系统的物理主备和应用服务报警监测。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上是最近遇到常见场景及策略总结，最重要的还是按照策略去<strong>执行</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java 架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>少一行代码，把线上环境搞崩了</title>
    <link href="/java/192b8638c566.html"/>
    <url>/java/192b8638c566.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天给大家带来一宗热乎乎的<strong>“5.1惨案“</strong>。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>领导给我打电话，反馈同事系统无法登录了。</p><p>当下第一反应就是：我没改代码啊，怎么会有问题。</p><p>抱怨归抱怨，身体还是很诚实，立马乖乖的下载日志，查看日志～</p><p>给大家看看报错信息，看大家能不能定位个大概问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">API处理错误：Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: unable to create <span class="hljs-keyword">new</span> <span class="hljs-title class_">native</span> thread<br></code></pre></td></tr></table></figure><p>OOM了，无法再创建新的处理线程。</p><p>收到领导反馈问题的时间是上午10:48分，而我开始查问题的时候已经是中午12:15左右了，这个时候系统已经自动恢复功能了，这说明释放出了空间能够让代码继续运行；</p><p>最开始我是导出的当天的运行日志，没有查看出端倪，继续找前一天的，我们需要找到第一次发生错误的日志。</p><p><img src="https://mkstatic.lianbian.net/202205051739855.png" alt="报错日志"></p><p>找到上边这段日志，基本上也知道触发OOM的原因是什么了。</p><p><strong>业务场景：</strong></p><p>在我的任务（禅道）系统里面，每天早上9点，有一个未完成任务任务的微信推送，因为推送的内容与每个同事信息相关，所以不能采取批量推送的方式，就循环了需要推送的用户（用户总数为183个），调用推送系统的推送消息接口。</p><p>理论上是没有一点压力的，本质就是调用微信的推送接口183次，微信这点推送还是能扛住的。</p><p>但是看这个日志，就是这个推送把JVM给弄OOM了。</p><p><img src="https://mkstatic.lianbian.net/202205052006774.png" alt="推送系统示意图"></p><p>找到触发OOM的原因，就继续跟踪业务代码，从禅道任务系统跟踪到微信推送系统（不是连边写的代码，但是秉承的解决问题的初衷，屎山也要看。）。首先脑海里进行一波分析，禅道任务系统是用PHP写的，他没有做任何的操作，就是发送一个http请求，出问题的概率应该不大，把重点的心思放在微信推送系统里边。</p><p>直到看到这段代码，我内心都崩溃了，我不知道是哪个想秀技术的程序员，秀出来的代码。</p><h2 id="看一段代码"><a href="#看一段代码" class="headerlink" title="看一段代码"></a>看一段代码</h2><p><img src="https://mkstatic.lianbian.net/202205052238651.png" alt="被秀的代码"></p><p>大家看出什么问题了吗？</p><p>我们看一段代码，首先不要陷入到细枝末节里面去看，要看这段代码、这个函数是要解决一个什么问题。</p><p><strong>异步批量发送微信消息模版</strong>是这个函数要解决的问题。</p><p>看到了2个引起警觉的代码<code>newFixedThreadPool</code>和<code>CompletableFuture.supplyAsync</code>。</p><p><strong>从上面这段代码，大家看出什么问题了吗？欢迎在留言区和我谈论。</strong></p><p>没看出问题的也没事，我们接着来补充并发编程的基础。</p><h2 id="补充基础"><a href="#补充基础" class="headerlink" title="补充基础"></a>补充基础</h2><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>创建固定数量的线程池。</p><p><strong>其实在阿里手册里边就有一条，不要使用封装好的这些创建线程池的方法。</strong></p><p>我们来看它具体的实现</p><p><img src="https://mkstatic.lianbian.net/202205052033040.png" alt="newFixedThreadPool的具体实现"></p><p>这里面又夹杂了一道常见面试题。</p><p><strong>创建线程池ThreadPoolExecutor有几个参数，你是怎么理解这几个参数的？在工作中，你是怎么设置的？</strong></p><p>这里先不散开来讲了，还是针对性的讲newFixedThreadPool。</p><p><code>ThreadPoolExecutor</code>继承自<code>AbstractExecutorService</code>，而<code>AbstractExecutorService</code>实现了<code>ExecutorService</code>接口。</p><p><img src="https://mkstatic.lianbian.net/202205052050749.png" alt="ThreadPoolExecutor方法"></p><p>7个参数：</p><ol><li><code>corePoolSize</code> ：线程池中核心线程数的最大值；</li><li><code>maximumPoolSize</code> ：线程池中能拥有最多线程数；</li><li><code>keepAliveTime</code> ：表示空闲线程的存活时间；</li><li><code>TimeUnit unit</code> ：表示keepAliveTime的单位；</li><li><code>workQueue</code> ：它决定了缓存任务的排队策略。对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的队列。这个队列需要一个实现了BlockingQueue接口的任务等待队列；</li><li><code>threadFactory</code> ：指定创建线程的工厂；</li><li><code>handler</code> ：表示当 <code>workQueue</code> 已满，且池中的线程数达到 <code>maximumPoolSize</code> 时，线程池拒绝添加新任务时采取的策略。</li></ol><p>回顾<code>newFixedThreadPool</code>的具体实现：</p><p><img src="https://mkstatic.lianbian.net/202205052102473.png" alt="newFixedThreadPool的具体实现"></p><p>它的核心线程数和最大线程数是一样，都是nThreads的变量的值，该变量由用户自己决定，所以说是固定大小线程池。此外，它每隔0毫秒回收一次线程，换句话说就是不回收线程，因为它的核心线程和最大线程数是一样，回收没有任何意义，此外，使用了<code>LinkedBlockingQueue</code>队列，该队列其实是有界队列，很多人误解了，只是它的初始值比较大，是Interger的最大值，Integer.MAX_VALUE。</p><p>回到最开始，我被秀的那段代码中，其实就是我调用一次微信模版推送方法，就会创建包含2个线程的线程池。</p><p>先继续补充第二个知识点。</p><h3 id="CompletableFuture-supplyAsync"><a href="#CompletableFuture-supplyAsync" class="headerlink" title="CompletableFuture.supplyAsync"></a>CompletableFuture.supplyAsync</h3><p>用某个线程池，去异步执行我的业务代码。</p><p><img src="https://mkstatic.lianbian.net/202205052154518.png" alt="模拟实现"></p><p>输出：</p><p><img src="https://mkstatic.lianbian.net/202205052155862.png" alt="输出效果"></p><p>因为没有调用<code>ExecutorService</code>的<code>shutdown</code>方法，启动的方法不会停止，会一直在运行状态。</p><h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>通过上面的讲解，其实我们已经知道了问题所在，就是创建线程没有调用线程池的<code>shutdown</code>，导致线程池一直等待任务，而这个任务永远不会到来了，等到达一个临界值之后，就会把系统拉垮。</p><p>为了证实这个理论，我们来写一段代码来验证下。</p><p><img src="https://mkstatic.lianbian.net/202205052236859.png" alt="伪代码验证问题"></p><p>输出：</p><p><img src="https://mkstatic.lianbian.net/202205052207133.png" alt="输出"></p><p>增加<code>shutdown</code>方法：</p><p><img src="https://mkstatic.lianbian.net/202205052208099.png" alt="增加shutdown方法"></p><p>结合前面的文章，这里留给大家一个思考题，加了shutdown方法的代码，真的能一直跑吗？pool到多少，会停止呢？</p><h2 id="最后我的解决方案"><a href="#最后我的解决方案" class="headerlink" title="最后我的解决方案"></a>最后我的解决方案</h2><p>可能大家都会以为我会直接增加shutdown方法来解决这个问题，但是我最后没有用shutdown来直接处理，而是把代码直接改成了</p><p><img src="https://mkstatic.lianbian.net/202205052235364.png" alt="直接for循环"></p><p>没有用线程池，没有用多线程的玩意儿，直接改成了for循环来修复了这个问题，因为从具体的业务出发，userIdList最多不过300个，我们是内部系统；还有就是充分相信微信的处理能力，如果这点有担忧的同学，可以改成异步的方法，我想着最后的结果反正就是推送不出去，就不去用复杂的异步调度了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>问题在你这里来了，不管是不是你的问题，先要解决问题，owner精神；</li><li>这里说一点题外话，恢复系统正常使用永远是第一要务，遇到问题，首先第一时间要预估恢复系统的时间，然后果断的做出判断，重启应用能够解决问题，就先重启应用，恢复系统之后，再去排查问题；</li><li>能用简单的技术解决问题，就用简单的技术，不要动不动就用牛刀杀鸡；</li><li>理解并注意前人提出的那些规范原理，有时候真的少些一行代码，能把线上服务器搞崩；</li></ol><p>我是连边，简化你的求知路径。</p><p>欢迎关注连边，不错过精彩内容。</p><p><img src="https://mkstatic.lianbian.net/202205052219629.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis是什么？</title>
    <link href="/redis/365360b38cf0.html"/>
    <url>/redis/365360b38cf0.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://mkstatic.lianbian.net/202204290656695.png" alt="redis是什么"></p><p>Redis是什么？</p><p>Redis（Remote Dictionary Server )，英文直译为远程字典服务，我们从4个方面来剖析：</p><ol><li>支持网络</li><li>基于内存亦可持久化的日志型数据库</li><li>Key Value数据库</li><li>提供多种语言的API</li></ol><p>以下我们来一一讲解。</p><p>支持网络，这点好理解，可以单独部署在网络上，实现应用程序对它的操作访问。</p><p><img src="https://mkstatic.lianbian.net/202204290628498.png" alt="支持网络"></p><p>基于内存亦可持久化的日志型数据库，这点就是说Redis的读写是基于内存的，这也是它的性能高的一个原因，但我们都知道，内存中的数据会随着服务器的重启而丢失，</p><p><img src="https://mkstatic.lianbian.net/202204290638360.png" alt="什么是Redis-内存"></p><p><img src="https://mkstatic.lianbian.net/202204290639517.png" alt="什么是Redis-内存重启"></p><p>而怎么样保证数据不丢失呢，对，就是持久化到磁盘上，以便 Redis 重启时能够从磁盘中恢复原有的数据，这个过程就叫做Redis持久化，这也是概念中所说的可基于内存亦可持久化的日志型数据库。</p><p><img src="https://mkstatic.lianbian.net/202204290638636.png" alt="什么是Redis-写入到磁盘"></p><p>这里深入讲解下持久化RDB和AOF。</p><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时，Redis会自动将内存中所有的数据生成一份副本并存储在硬盘中，这个过程被称为“快照”。“快照”，就类似于拍照，摁下快门那一刻，所定格的照片，就称为“快照”。但是RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照之后更改的所有数据。为了降低因进程中止导致的数据丢失风险，可以使用AOF方式实现数据持久化。AOF持久化是以日志追加的形式记录服务器所处理的每一个新增、删除操作，查询操作不记录，以文本的方式记录，文件中可以看到详细的操作记录。</p><p>简单对比下RDB与AOF的优缺点。</p><p><strong>RDB的优缺点：</strong></p><p>优点：RDB持久化文件，速度比较快，而且存储的是一个二进制文件，传输起来很方便。</p><p>缺点：RDB无法保证数据的绝对安全，有时候就是1s也会有很大的数据丢失。</p><p><strong>AOF的优缺点：</strong></p><p>优点：AOF相对RDB更加安全，一般不会有数据的丢失或者很少，官方推荐同时开启AOF和RDB。</p><p>缺点：AOF持久化的速度，相对于RDB较慢，存储的是一个文本文件，到了后期文件会比较大，传输困难。</p><p>接下来我们来继续理解Key Value数据库，常见的key value数据库有memcache、redis；而在Java语言里边有一个常用的数据类型Map也是典型的key value，简而言之就是一个key，对应着一个值；它的查询复杂度为O(1)；这里也可以和哈希关联起来，若关键字为key，则其值存放在f(key)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为<strong>哈希函数</strong>，按这个思想建立的表为<strong>哈希表</strong>。</p><p><img src="https://mkstatic.lianbian.net/202204290639032.png" alt="什么是Redis-key-value"></p><p>最后一点，提供多种语言的API，就是官方提供了很编程语言的驱动，能够方便的各种应用语言通过驱动来操作Redis API。</p><p><img src="https://mkstatic.lianbian.net/202204290637581.png" alt="什么是Redis-驱动"></p><p>谢谢收看本期内容，我们下期再见。</p><p>我是连边，简化你的求知路径。</p><p>欢迎关注连边，不错过精彩文章。</p><p><img src="https://mkstatic.lianbian.net/202204290653427.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>真的有必要定义VO，BO，PO，DO，DTO吗？</title>
    <link href="/java/58c0e3305e12.html"/>
    <url>/java/58c0e3305e12.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天给大家带来一篇关于<code>VO，BO，PO，DO，DTO</code>的文章，阅读完这篇文章之后，希望大家对<code>VO，BO，PO，DO，DTO</code>有自己的见解。</p><p><img src="https://mkstatic.lianbian.net/202204201300400.png" alt="VO，BO，PO，DO，DTO"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在讲具体的概念之前，我们先简单的讲一讲我们<code>MVC</code>开发模式。</p><p><strong>MVC的简单定义：</strong></p><p><code>M</code>层负责与数据库打交道；</p><p><code>C</code>层负责业务逻辑的编写；</p><p><code>V</code>层负责给用户展示（针对于前后端不分离的项目，不分离项目那种编写模版的方式，理解<code>V</code>的概念更直观）。</p><p>而我们今天要说的<code>VO，BO，PO，DO，DTO</code>呢，就是穿梭在这<code>M、V、C</code>层之间的<code>实体传输对象</code>。</p><p><img src="https://mkstatic.lianbian.net/202204201306683.png" alt="实体传输对象示意图"></p><ul><li>VO（<code>View Object</code>）：<strong>视图对象</strong>，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</li><li>DTO（<code>Data Transfer Object</code>）：<strong>数据传输对象</strong>，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，更符合泛指用于展示层与服务层之间的数据传输对象。</li><li>BO（<code>Business Object</code>）：<strong>业务对象</strong>，把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。</li><li>PO（<code>Persistent Object</code>）：<strong>持久化对象</strong>，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。</li><li>DO（<code>Domain Object</code>）：<strong>领域对象</strong>，就是从现实世界中抽象出来的有形或无形的业务实体。</li></ul><h2 id="有必要用吗？"><a href="#有必要用吗？" class="headerlink" title="有必要用吗？"></a>有必要用吗？</h2><p>项目中真的有必要定义<code>VO，BO，PO，DO，DTO</code>吗？</p><p>还是要理性看待这个问题，要看我们项目“目的地”是什么。</p><p>如果项目比较小，是一个简单的<code>MVC</code>项目，又是<code>单兵作战</code>，我不建议使用<code>VO，BO，PO，DO，DTO</code>，直接用<code>POJO</code>负责各个层来传输就好，因为这种项目的“目的地”是快速完成。</p><p>而我们更多的时候，是持续迭代的团队协作项目，这个时候我们就建议用<code>VO，BO，PO，DO，DTO</code>，而且团队内要达成共识，形成一个<code>标准规范</code>。</p><ol><li>业务复杂，人员协同性要求高的场景下，这些规范性的东西不按着来虽然不会出错，程序照样跑，但是遵守规范会让程序更具扩展性和可读性；</li><li>让类语义更明确，很容易知道类的含义；</li></ol><p>其实就是提升项目的<code>可扩展性</code>、<code>可维护性</code>与<code>可阅读性</code>。</p><p>提升这些性能的尽头是<code>经济效益</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章很短，最后稍微总结一下，不管用哪种方式，只要团队内定义好一种适应的协同规范就行。</p><p>没有一个<code>绝对好</code>与<code>绝对坏</code>的方式方法。</p><p>团队规范的尽头能提升项目的<code>可扩展性</code>、<code>可维护性</code>与<code>可阅读性</code>，从而降低bug率。</p><p>另附这些概念命名规范：</p><ul><li>数据对象：xxxPO，xxx即为数据表名。(也可DO)</li><li>数据传输对象：xxxDTO，xxx为业务领域相关的名称。</li><li>展示对象：xxxVO，xxx一般为网页名称。</li><li>业务对象：xxxBO，xxx是业务名称。</li></ul><p>参考链接：<a href="https://mp.weixin.qq.com/s/3-wA3hh75pgoTJu0Rz3SXw">https://mp.weixin.qq.com/s/3-wA3hh75pgoTJu0Rz3SXw</a></p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202204201259459.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章搞定Redis Stream</title>
    <link href="/redis/493ee6a41e5c.html"/>
    <url>/redis/493ee6a41e5c.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是连边。</p><p>今天给大家带来一篇关于<code>Redis Stream</code>的文章，文章会从消息队列的基本概念、然后基于Redis Stream基本操作，顺带着会讲Redis Stream的存储结构，最后配合在<code>Spring Boot</code>框架来讲解实战。阅读完这篇文章以后，基本上就能把Redis Stream拿捏住。</p><p>话不多说，开始～</p><p>也还是老规矩，先上导读图。</p><p><img src="https://mkstatic.lianbian.net/202204112322351.png" alt="搞定Redis Stream"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>Redis Stream</code> 是<code>Redis5.0</code>推出的一种专门用来处理<code>消息队列</code>场景的高级数据结构，是Redis下消息队列的最佳实现。</p><p><img src="https://mkstatic.lianbian.net/202204070735521.png" alt="stream全局图-不是我画的"></p><p>这是一个很好的Redis Stream知识体系图，现在看着看不懂这个图也没有关系，我会由浅入深的给大家剖析该体系图。</p><h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><p><code>队列</code>是一种数据结构，对应到我们生活中的例子，就是排队。讲究着<strong>先来先处理的原则</strong>，目的是为了避免混乱与系统瘫痪。</p><p><strong>消息队列把我们具体的业务，都抽象成为“消息”。排队做核酸，也可以叫做“核酸”队列。</strong></p><p>刚说了队列是为了避免混乱与系统瘫痪，它还有一些其他的作用：</p><ol><li>消峰填谷</li></ol><p>这点表现最明显的就是我们常说的秒杀系统，访问量在某一个刻，到达巅峰，然后又断崖式下跌。</p><p>根据具体的业务场景，把业务处理的压力压入到消息队列中，以时间轴为水平线，来处理业务。</p><p><img src="https://mkstatic.lianbian.net/202204041252508.png" alt="消峰填谷"></p><ol start="2"><li>异步解耦</li></ol><p>假如有一个电商系统，在商品下单后，需要通知客服小二核对地址，需要通知物流仓储系统发货，需要营销中心发放优惠券 等等一些业务。</p><p><img src="https://mkstatic.lianbian.net/202204041252375.png" alt="异步解耦"></p><p>消息队列还有一些其他的作用，以上两个是比较典型的。</p><p>在<code>Reids</code>没有推出<code>Stream</code>数据类型的时候，我们也可以用<code>Redis</code>来做消息队列。分别是利用<code>Reids</code>的<code>list</code>和<code>订阅/发布</code>两种数据类型。</p><ol><li>list</li></ol><p>用push命令压入队列，用pop命令来拿出队列里边的消息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 在 lianbianKey 里边压入2个消息，messageContent1、messageContent2</span></span><br>lpush lianbianKey messageContent1<br>lpush lianbianKey messageContent2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 在另外一端，lpop命令取出元素</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># lpop移除并获取第一个元素</span></span><br>lpop lianbainKey<br></code></pre></td></tr></table></figure><ol start="2"><li>订阅/发布</li></ol><p>这个模式，和我们平常看电视频道类似，把电视台切换到湖南卫视，你就能自然看到当前电视台播放的节目（快乐大本营、天天向上 …），就相当于你订阅了湖南卫视频道，在湖南卫视电视台发布节目的时候，你就能够很自然的接收到。但是这种模式有一个弊端，就是错过了就是错过了，错过了19:00的新闻联播，就是错过了。</p><p>都能实现消息队列，为什么<code>Redis</code>在5.0的版本里，还推出<code>Stream</code>数据类型呢？与<code>list</code>和<code>订阅/发布</code>又有什么异同呢？</p><h2 id="为什么要Redis-Stream"><a href="#为什么要Redis-Stream" class="headerlink" title="为什么要Redis Stream"></a>为什么要Redis Stream</h2><ol><li><strong>标准化操作</strong></li></ol><p>在没有<code>Redis Stream</code>推出的时候，我们知道利用<code>Reids</code>能够实现队列功能，但是大家实现得五花八门，没有一个统一的、标准的实现方式。最后导致的就是<code>Redis队列生态</code>显得乱，在推出Stream之后，后续实现队列都会使用该新的数据类型，利于标准化。</p><ol start="2"><li><strong>取长补短</strong></li></ol><p>不管是<code>list</code>还是<code>订阅/发布</code>模式，都有其弊端，比如list不能友好的重复消费，需要重复消费的话，需要程序代码去控制；而<code>订阅/发布模式</code>是一种转发消息的模式，只有订阅者在线的时候才能接收到消息，订阅者不在线期间产生的消息，就丢掉了。而Stream，有借鉴Kafka一些市面上成熟的消息队列的思想，可以消费失败重复消费，消息是持久化的。</p><ol start="3"><li><strong>降低门槛</strong></li></ol><p>不管是之前的<code>list</code>还是<code>订阅/发布</code>模式，其实就不能说是严谨的消息队列，它只能说是我们实现消息列队的基本数据结构，而<code>Stream</code>可以说是降低了我们在<code>Redis</code>中使用消息队列的门槛，封装了一些消费者常见的角色（生产者、主题、元素、消费者、消费组）。</p><h2 id="消息队列的几个重要元素"><a href="#消息队列的几个重要元素" class="headerlink" title="消息队列的几个重要元素"></a>消息队列的几个重要元素</h2><p>从上面的讲解，我们把消息队列中的几个概念再着重讲一下，如果熟悉其他的消息队列的，还是很容易理解。</p><ol><li>生产者</li></ol><p>生产消息的服务或者项目，比如上边例子中的<strong>商品下单</strong>。</p><ol start="2"><li>主题</li></ol><p>主题就相当于我们电视台的频道，生产者负责把消息往主题里边塞，塞进消息之后，监听了该主题的消费者会从该主题里边拿出消息。在Redis Stream里边，主题名称就是我们的stream key键值。现在不懂也没关系，在后边直观体验环节能够直观感受到。</p><ol start="3"><li>元素</li></ol><p>也可以叫做消息，就是我们生产者往主题里边塞的内容，都可以称之为<strong>消息</strong>、<strong>元素</strong>。</p><ol start="4"><li>消费者</li></ol><p>监听主题拿出消息，对消息进行处理的，叫做消费者。如最上边例子中的拿订单号的仓库系统、物流系统、营销系统。</p><p>讲完了基本理论，我们用命令行的方式直观感受一下<code>Redis Stream</code>。</p><h2 id="直观体验Redis-Stream"><a href="#直观体验Redis-Stream" class="headerlink" title="直观体验Redis Stream"></a>直观体验Redis Stream</h2><p><strong>安装</strong></p><p>windows下，很多开发的时候，还是使用3.0+的版本redis（微软编译的安装包，但是一直没更新了。），但是<code>Stream</code>是Redis5.0的新特性，在github上找到了大牛的编译版本：</p><p><a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p><p>也可以关注我的公众号回复<code>redis5</code>获取百度网盘下载地址。</p><p>在安装好之后，就可以进行命令行的玩转了。</p><h3 id="进入redis命令行"><a href="#进入redis命令行" class="headerlink" title="进入redis命令行"></a>进入redis命令行</h3><p><img src="https://mkstatic.lianbian.net/202204052136097.png" alt="redis命令行"></p><h3 id="创建主题并创建消息"><a href="#创建主题并创建消息" class="headerlink" title="创建主题并创建消息"></a>创建主题并创建消息</h3><p>创建<code>lianbianKey</code>主题，追加 <code>nickName LianBian</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XADD key ID field string [field string ...]<br></code></pre></td></tr></table></figure><p><img src="https://mkstatic.lianbian.net/202204052143572.png" alt="xadd追加和创建主题"></p><p>可视化工具查看：</p><p><img src="https://mkstatic.lianbian.net/202204052146648.png" alt="可视化工具查看"></p><h3 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h3><p>消费在<code>lianbianKey</code>主题中刚追加 <code>nickName LianBian</code>消息。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure><p>其中：</p><ol><li>[COUNT count]，用于限定获取的消息数量；</li><li>[BLOCK milliseconds]，用于设置XREAD为阻塞模式，默认为非阻塞模式；</li><li>ID，用于设置由哪个消息ID开始读取。使用0表示从第一条消息开始。（本例中就是使用0）此处需要注意，消息队列ID是单调递增的，所以通过设置起点，可以向后读取。在阻塞模式中，可以使用$，表示最新的消息ID。（在非阻塞模式下$无意义）。</li></ol><p>XRED读消息时分为阻塞和非阻塞模式，使用BLOCK选项可以表示阻塞模式，需要设置阻塞时长。非阻塞模式下，读取完毕（即使没有任何消息）立即返回，而在阻塞模式下，若读取不到内容，则阻塞等待。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xread block 10000 streams lianbianKey $<br></code></pre></td></tr></table></figure><p>阻塞读取lianbianKey主题的消息，最长阻塞10s，读到内容之后，立即返回。</p><p><img src="https://mkstatic.lianbian.net/202204052155202.png" alt="阻塞消费"></p><p>典型的队列就是 XADD 配合 XREAD Block 完成。XADD负责生成消息，XREAD负责消费消息。</p><h3 id="消费组模式"><a href="#消费组模式" class="headerlink" title="消费组模式"></a>消费组模式</h3><p>上边讲解的是一个消费者的模式，也是独立消费模式；Redis Stream也支持消费组模式，这点是借鉴了kafka的思想。当我们的生产者生产的消息过快，单个消费者的消费处理速度不能满足业务，我们就可以考虑使用消费组模式，来加快消息的处理。</p><p>多个消费者配合协作来消费同一个消息队列，比如消息队列中有10条消息，三个消费者分别消费其中的某些消息，比如消费者A消费消息1、2、5、8，消费者B消费消息4、9、10，而消费者C消费消息3、6、7。</p><p><img src="https://mkstatic.lianbian.net/202204052201508.jpg" alt="文字对应的消费组模型-不是我画的"></p><p>如果觉得上图有一些乱，可以看下边的结构图，来加深理解。</p><p><img src="https://mkstatic.lianbian.net/202204070745630.png" alt="消费组结构图-不是我画的"></p><p>消费者组模式的支持主要由两个命令实现：</p><ol><li>XGROUP，用于管理消费者组，提供创建组，销毁组，更新组起始消息ID等操作</li><li>XREADGROUP，分组消费消息操作</li></ol><p>消费组演示：</p><ol><li>创建消费组</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XGROUP create lianbianKey lianbianGroup 0<br></code></pre></td></tr></table></figure><ol start="2"><li>创建消息</li></ol><p><img src="https://mkstatic.lianbian.net/202204052208819.png" alt="创建消息"></p><ol start="3"><li>消费组模式消费消息</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XREADGROUP group lianbianGroup consumerA count 1 streams lianbianKey &gt;<br></code></pre></td></tr></table></figure><p><img src="https://mkstatic.lianbian.net/202204052211840.png" alt="消费组模式第一条消息"></p><p>注意对比和压入时候的消息ID；</p><p>依次分配给<code>consumerB</code>、<code>consumerC</code>来消费：</p><p><img src="https://mkstatic.lianbian.net/202204052215363.png" alt="依次消费"></p><p><strong>可以进行组内消费的基本原理是，STREAM类型会为每个组记录一个最后处理（交付）的消息ID（last_delivered_id），这样在组内消费时，就可以从这个值后面开始读取，保证不重复消费。</strong></p><p>讲完了独立消费、消费组消费，接下来继续讲<strong>消费确认</strong>。</p><h3 id="ACK（消息确认）"><a href="#ACK（消息确认）" class="headerlink" title="ACK（消息确认）"></a>ACK（消息确认）</h3><p>在消费消息之后，我们是要给消息队列一个反馈，Redis Stream是用的<code>xack</code>来完成这部分工作的。</p><p><img src="https://mkstatic.lianbian.net/202204052242986.png" alt="消费确认示意简图"></p><p>前面我们消费了几条消息，但是我们并没有消费确认，我们借助<code>xpending</code>命令来查看下：</p><p><img src="https://mkstatic.lianbian.net/202204052244639.png" alt="未确认消息统计"></p><p>表示有哪些消息没有确认，我们来操作下消息确认</p><p><img src="https://mkstatic.lianbian.net/202204052249394.png" alt="xack消费确认"></p><p>在我们操作了ack命令之后，挂载在consumerA的数量减少了1（回顾最开始的那个体系图，挂载在消费组图中的pending_ids[]吗？就是记录的这个）。</p><p>基本操作讲完了，我们稍微总结一下。</p><p>xadd命令创建主题和消息，然后可以采取两种模式来消费消息，分别是<strong>独立消费</strong>和<strong>消费组消费</strong>，在消费消息之后，我们要使用ack来确认消费，至此，一条消息才算被处理完毕。</p><p><img src="https://mkstatic.lianbian.net/202204082236528.png" alt="stream全局图-不是我画的"></p><p>现在再看这张图，是不是有很多东西已经理解了。</p><p>上边讲的都是消息的正常情况，但是在我们的实际场景中，难免有一些异常情况，接下来，我继续给大家讲解Redis Stream是怎么应对那些实际场景中的异常情况的。</p><h3 id="PEL（等待列表）"><a href="#PEL（等待列表）" class="headerlink" title="PEL（等待列表）"></a>PEL（等待列表）</h3><p>某个消费者，读取了某条消息之后进程就宕机了，这条消息可能会丢失，因为其他消费者不能再次消费到该消息了，这种情况下，Redis Stream是怎么样保证这条消息不丢失的呢？</p><p>看到数据丢失，我们第一个想到的应该是要想到备份。对，就是备份。</p><p>在消息读取的时候，同时会在pending列表中存入一个消息ID，当客户端重新连上之后，可以再次收到PEL中的消息ID列表。这也是我们<code>xpending</code>命令的基本底层原理。</p><p>xpending命令</p><p><img src="https://mkstatic.lianbian.net/202204082329393.png" alt="PEL详情"></p><p>xpending命令有4个属性：</p><ol><li>消息ID</li><li>所属消费者</li><li>IDLE，已读取时长</li><li>消息被读取次数</li></ol><p>有了这样一个Pending机制，就意味着在某个消费者读取消息但未处理后，消息是不会丢失的。</p><p>此时还有一个问题，就是若某个消费者宕机之后，没有办法再上线了，那么就需要将该消费者Pending的消息，转移给其他的消费者处理，就是消息转移。</p><h3 id="消息转移"><a href="#消息转移" class="headerlink" title="消息转移"></a>消息转移</h3><p>消息转移的操作时将某个消息转移到自己的Pending列表中。使用语法<code>XCLAIM</code>来实现，需要设置组、转移的目标消费者和消息ID，同时需要提供IDLE（已被读取时长），只有超过这个时长，才能被转移。演示如下：</p><p><img src="https://mkstatic.lianbian.net/202204082338305.png" alt="待转移的消息"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">XCLAIM lianbianKey lianbianGroup consumerB 3600000 1649166116013-0<br></code></pre></td></tr></table></figure><p><img src="https://mkstatic.lianbian.net/202204082339586.png" alt="转移结果"></p><p>以上代码，完成了一次消息转移。转移除了要指定ID外，还需要指定IDLE，保证是长时间未处理的才被转移。被转移的消息的IDLE会被重置，用以保证不会被重复转移，以为可能会出现将过期的消息同时转移给多个消费者的并发操作，设置了IDLE，则可以避免后面的转移不会成功，因为IDLE不满足条件。例如下面的连续两条转移，第二条不会成功。</p><p><img src="https://mkstatic.lianbian.net/202204082340480.png" alt="重复转移"></p><p>上边的命令因为时间没到，重复转移失败，还是归属于消费者B。</p><p>这就是消息转移。至此我们使用了一个Pending消息的ID，所属消费者和IDLE的属性，还有一个属性就是消息被读取次数，该属性的作用由于统计消息被读取的次数，包括被转移也算。这个属性主要用在判定是否为错误数据上。</p><h3 id="坏消息问题，Dead-Letter，死信问题"><a href="#坏消息问题，Dead-Letter，死信问题" class="headerlink" title="坏消息问题，Dead Letter，死信问题"></a>坏消息问题，Dead Letter，死信问题</h3><p>正如上面所说，如果某个消息，不能被消费者处理，也就是不能被XACK，这是要长时间处于Pending列表中，即使被反复的转移给各个消费者也是如此。此时该消息的被读取次数就会累加（上一节的例子可以看到），当累加到某个我们预设的临界值时，我们就认为是坏消息（也叫死信，DeadLetter，无法投递的消息），由于有了判定条件，我们将坏消息处理掉即可，删除即可。删除一个消息，使用<code>XDEL</code>语法。（这里是说被读取次数是我们在做业务的时候判断是否需要删除的依据，而xdel就是stream的一个普通的命令，删除队列中的某个消息。）</p><p><img src="https://mkstatic.lianbian.net/202204082345023.png" alt="xdel"></p><p><img src="https://mkstatic.lianbian.net/202204082348833.png" alt="在pending中还存在"></p><p>是普通命令，就记得xack</p><p><img src="https://mkstatic.lianbian.net/202204082349405.png" alt="xack后，PEL中无数据"></p><p>至此，Redis Stream的直观体验告一段落，大家是否熟悉了呢？</p><p>赶紧实践一番吧。</p><h2 id="SpringBoot案例实战"><a href="#SpringBoot案例实战" class="headerlink" title="SpringBoot案例实战"></a>SpringBoot案例实战</h2><p>在实际编码之前， 我们稍微整理下思路。</p><p>首先我们需要有生产者和消费者两个角色。生产者不断产生消息，消费者不断处理消息。</p><p>生产者我们直接用命令行替代，编码实现实时消费的模块。</p><p>最后达到的效果就是，命令行往指定的Key插入消息，在代码的命令行输出能看到消费的消息。</p><p><strong>引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>创建监听</strong></p><p>监听需要继承<code>StreamListener</code>类，重写<code>onMessage</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisStreamConsumerListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StreamListener</span>&lt;String, MapRecord&lt;String ,String, String&gt;&gt; &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(RedisStreamConsumerListener.class);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(MapRecord&lt;String, String, String&gt; message)</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;message:: id=&#123;&#125;, body=&#123;&#125;&quot;</span>, message.getId(), message.getValue());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注册Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> StreamMessageListenerContainer <span class="hljs-title function_">streamMessageListenerContainer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">processors</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(processors, processors, <span class="hljs-number">0</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(), r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>            thread.setName(<span class="hljs-string">&quot;async-stream-comsumer-&quot;</span> + index.getAndDecrement());<br>            thread.setDaemon(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> thread;<br>        &#125;);<br><br>        StreamMessageListenerContainer.<span class="hljs-type">StreamMessageListenerContainerOptions</span> <span class="hljs-variable">streamMessageListenerContainerOptions</span> <span class="hljs-operator">=</span> StreamMessageListenerContainer.StreamMessageListenerContainerOptions.builder().batchSize(<span class="hljs-number">10</span>).executor(executor).errorHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleError</span><span class="hljs-params">(Throwable t)</span> &#123;<br>                t.printStackTrace();<br>            &#125;<br>        &#125;).pollTimeout(Duration.ZERO).serializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>()).build();<br>        <span class="hljs-type">StreamMessageListenerContainer</span> <span class="hljs-variable">streamMessageListenerContainer</span> <span class="hljs-operator">=</span> StreamMessageListenerContainer.create(redisConnectionFactory, streamMessageListenerContainerOptions);<br>        streamMessageListenerContainer.receive(Consumer.from(<span class="hljs-string">&quot;lianbianGroup&quot;</span>, <span class="hljs-string">&quot;consumer-a&quot;</span>), StreamOffset.create(<span class="hljs-string">&quot;lianbianKey&quot;</span>, ReadOffset.lastConsumed()), streamListener);<br>        streamMessageListenerContainer.start();<br>        <span class="hljs-keyword">return</span> streamMessageListenerContainer;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>启动看效果</strong></p><p><img src="https://mkstatic.lianbian.net/202204112311256.png" alt="命令行生产者"></p><p><img src="https://mkstatic.lianbian.net/202204112311670.png" alt="控制台输出结果"></p><h2 id="源代码地址"><a href="#源代码地址" class="headerlink" title="源代码地址"></a>源代码地址</h2><p>完整代码放在github上了，需要的可以自取：</p><p><a href="https://github.com/lianbian/ReidsStreamDemo">https://github.com/lianbian/ReidsStreamDemo</a></p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202204112323509.jpg" alt="订阅号@连边"></p><p>参看链接：</p><p><a href="https://zhuanlan.zhihu.com/p/60501638">https://zhuanlan.zhihu.com/p/60501638</a></p><p><a href="http://www.redis.cn/topics/streams-intro.html">http://www.redis.cn/topics/streams-intro.html</a></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClickHouse数据类型</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/42572c4acee4.html"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/42572c4acee4.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天我们继续来学习<code>ClickHouse</code>的数据类型，其实这块资料重要的资料还是看官网。</p><p><a href="https://clickhouse.com/docs/en/sql-reference/data-types/">官网：ClickHouse数据类型</a></p><p>老规矩，还是先上阅读导读：</p><p><img src="https://mkstatic.lianbian.net/202204010756622.png" alt="ClickHouse数据类型"></p><h2 id="分类与语法规则"><a href="#分类与语法规则" class="headerlink" title="分类与语法规则"></a>分类与语法规则</h2><p><code>ClickHouse</code>与<code>MySQL</code>语法是及其相似的，我们先来看一个创建表语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dt<br>(<br>    `id` UInt32<br>    `name` String,<br>)<br>ENGINE <span class="hljs-operator">=</span> TinyLog;<br></code></pre></td></tr></table></figure><p><code>id UInt32</code>中，id为字段名称，UInt32是我们的数据类型，就是语法规则，为了方便记忆，我结合语法规则和使用场景把数据类型分成了四种类型：</p><ol><li>基本数据类型</li></ol><p>基本数据类型是指我们Int、String …常见类型。</p><ol start="2"><li>函数数据类型</li></ol><p>看如下创建语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> lc_t<br>(<br>    `id` UInt16,<br>    `strings` LowCardinality(String)<br>)<br>ENGINE <span class="hljs-operator">=</span> MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id<br></code></pre></td></tr></table></figure><p><code>strings LowCardinality(String)</code>的申明部分，带着<code>()</code>与我们的函数调用相似，所以我给他取名叫做<code>函数类型</code>。</p><ol start="3"><li>场景类型</li></ol><p>IP地址、经纬度都有固定的存储格式，而且也很常用，很多数据库都为常见的场景做了单独的类型，我们把这一类，归为<code>场景类型</code>。</p><ol start="4"><li>其他</li></ol><p>那些实在不好分类的几种数据类型，就把它放在<code>其他类型</code>里。</p><p>做好了分类，我们依次来学习各种数据类型。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>与我们变成语言一样，常见的这一些类型。</p><h3 id="Int-amp-Boolean"><a href="#Int-amp-Boolean" class="headerlink" title="Int &amp; Boolean"></a>Int &amp; Boolean</h3><p><code>ClickHouse</code>数据库的<code>Int</code>类型区分有符号与无符号，命名也非常的简单粗暴，用简单直接的命名顶替了其他数据库的<code>Int</code>、<code>BigInt</code>之类的。</p><table><thead><tr><th>类型</th><th>取值范围</th></tr></thead><tbody><tr><td>Int8</td><td>[-128 : 127]</td></tr><tr><td>Int16</td><td>[-32768 : 32767]</td></tr><tr><td>Int32</td><td>[-2147483648 : 2147483647]</td></tr><tr><td>…</td><td></td></tr><tr><td>UInt8</td><td>[0 : 255]</td></tr><tr><td>UInt16</td><td>[0 : 65535]</td></tr><tr><td>UInt32</td><td>[0 : 4294967295]</td></tr></tbody></table><p>U开头的表示无符号，同样的空间，能够存储更大的值。上面表格没有写全，最大可以到<code>Int256、UInt256</code>。</p><p>这里需要单独拎出来说一下的是，在我们的<code>ClickHouse</code>里边，没有单独的<code>Boolean</code>类型，可以用<code>Int8</code>的0和1来表示。</p><h3 id="Float-amp-Decimal"><a href="#Float-amp-Decimal" class="headerlink" title="Float &amp; Decimal"></a>Float &amp; Decimal</h3><p>官方是推荐我们使用<code>Int</code>存储，比如我们存金额的时候，会采取存<code>分</code>为单位，这样子就避免存小数。</p><p>但是业务开发的时候，难免会碰到需要保留小数的后多少位，比如我们熟悉的<code>圆周率</code>。</p><table><thead><tr><th>类型</th><th>取值范围</th></tr></thead><tbody><tr><td>Float32</td><td>-2147483648 - 2147483647</td></tr><tr><td>Float64</td><td>-9223372036854775808 - 9223372036854775807</td></tr><tr><td></td><td></td></tr><tr><td>Decimal32(S)</td><td>( -1 * 10^(9 - S), 1 * 10^(9 - S) )</td></tr><tr><td>Decimal64(S)</td><td>( -1 * 10^(18 - S), 1 * 10^(18 - S) )</td></tr><tr><td>Decimal128(S)</td><td>( -1 * 10^(38 - S), 1 * 10^(38 - S) )</td></tr><tr><td>Decimal256(S)</td><td>( -1 * 10^(76 - S), 1 * 10^(76 - S) )</td></tr></tbody></table><h3 id="String-amp-FixedString-amp-UUID"><a href="#String-amp-FixedString-amp-UUID" class="headerlink" title="String &amp; FixedString &amp; UUID"></a>String &amp; FixedString &amp; UUID</h3><p>在<code>ClickHouse</code>中，没有<code>varchar</code>这种结构，就是简单直接的提供了<code>String</code>类型，如果我们知道值是固定的长度，就用<code>FixdString</code>类型，它表示定长，与我们语言中的数组一样，申明的时候就固定了长度。比如我们存储MD5用<code>FixedString(16)</code> ，存储SHA256用 <code>FixedString(32)</code> 。</p><p>但是他提供了一种特殊的类型，就是<code>UUID</code>，专门用来存储UUID的值。</p><blockquote><p>UUID：通用唯一标识符 (UUID) 是一个 16 字节的数字，用于标识记录。</p></blockquote><p><code>ClickHouse</code>里边，<a href="https://clickhouse.com/docs/en/sql-reference/functions/uuid-functions/">generateUUIDv4</a>可以生成UUID</p><h3 id="Date-amp-DateTime"><a href="#Date-amp-DateTime" class="headerlink" title="Date &amp; DateTime"></a>Date &amp; DateTime</h3><p>时间类型，Date与DateTime的区别在于格式不一样，Date里边细分Date和Date32，DateTime细分DateTime64，他们之间的区别在于能存储的范围不一样。</p><table><thead><tr><th>名称</th><th>格式</th><th>取值范围</th></tr></thead><tbody><tr><td>Date</td><td>2022-04-01</td><td>[1970-01-01, 2149-06-06]</td></tr><tr><td>Date32</td><td>2022-04-01</td><td>[1925-01-01, 2283-11-11]</td></tr><tr><td>DateTime</td><td>2022-04-01 00:00:00</td><td>[1970-01-01 00:00:00, 2106-02-07 06:28:15]</td></tr><tr><td>DateTime64</td><td>2022-04-01 00:00:00</td><td>[1925-01-01 00:00:00, 2283-11-11 23:59:59.99999999] (注意: 最大值的精度是8)</td></tr></tbody></table><p><code>DateTime64</code> 类型可以像存储其他数据列一样存储时区信息，时区会影响 <code>DateTime64</code> 类型的值如何以文本格式显示。</p><h3 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3><p>这个枚举和我们编程语言中的枚举可以说是一一对应了，分为8bit的枚举和16bit的枚举。</p><p>8 位枚举。它最多可以包含在 [-128, 127] 范围内枚举的 256 个值。 </p><p>16 位枚举。它最多可以包含 [-32768, 32767] 范围内枚举的 65536 个值。</p><p>如果使用基于ClickHouse来实现数据字典，这将是一个值得深入研究的东西。</p><p><a href="https://clickhouse.com/docs/en/sql-reference/data-types/enum/">https://clickhouse.com/docs/en/sql-reference/data-types/enum/</a></p><p>还有很多类型，我把它简单的归类一下，就不一一详细说明了，可以自行看文档。</p><h2 id="函数数据类型"><a href="#函数数据类型" class="headerlink" title="函数数据类型"></a>函数数据类型</h2><h3 id="Nullable"><a href="#Nullable" class="headerlink" title="Nullable"></a>Nullable</h3><h3 id="LowCardinality"><a href="#LowCardinality" class="headerlink" title="LowCardinality"></a>LowCardinality</h3><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h3 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h3><h3 id="Nested"><a href="#Nested" class="headerlink" title="Nested"></a>Nested</h3><h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><h3 id="SimpleAggregateFunction"><a href="#SimpleAggregateFunction" class="headerlink" title="SimpleAggregateFunction"></a>SimpleAggregateFunction</h3><h2 id="场景类型"><a href="#场景类型" class="headerlink" title="场景类型"></a>场景类型</h2><h3 id="Map-Json？"><a href="#Map-Json？" class="headerlink" title="Map | Json？"></a>Map | Json？</h3><h3 id="Geo-保存经纬度"><a href="#Geo-保存经纬度" class="headerlink" title="Geo 保存经纬度"></a>Geo 保存经纬度</h3><h3 id="Domains-域名-IP体系"><a href="#Domains-域名-IP体系" class="headerlink" title="Domains 域名 IP体系"></a>Domains 域名 IP体系</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="未定义-Nothing"><a href="#未定义-Nothing" class="headerlink" title="未定义 Nothing"></a>未定义 Nothing</h3><h3 id="时间戳-Interval"><a href="#时间戳-Interval" class="headerlink" title="时间戳 Interval"></a>时间戳 Interval</h3><p>官方文档：</p><p><a href="https://clickhouse.com/docs/en/sql-reference/data-types/">https://clickhouse.com/docs/en/sql-reference/data-types/</a></p><p><a href="https://help.aliyun.com/document_detail/146000.html">https://help.aliyun.com/document_detail/146000.html</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202204010752600.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clickhouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>立项的那些事</title>
    <link href="/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/32f5423cb7f0.html"/>
    <url>/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/32f5423cb7f0.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天不写技术文章，写一写项目立项的要素、优缺点以及注意点。</p><h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><p>在项目立项会议的时候，要交代好几个要素：</p><ol><li>项目背景</li><li>项目职责</li><li>项目经理</li><li>项目成员</li></ol><p>以上四个要素，是要在立项之初就要清晰定义下来的，举例说一说如果不定义其中某个要素可能带来的后果。</p><ul><li>不说明项目背景</li></ul><p>小到任务，大到项目，把项目背景交代清楚还是很有必要的，让项目的相关人员知道<strong>为什么出发</strong>，也有很多决策层觉得执行层不需要知道项目的背景，只管执行就行，其实让执行层知道决策层的蓝图，是有助于项目开发执行效率的提升的。</p><ul><li>不清楚项目职责</li></ul><p>这一点就是项目的边界问题，立项大会上要有明确的定义，不能模糊。边界上有模糊的地方，一定要找上相关的团队，在立项大会上或者在立项大会之后，找上相关团队讨论清楚，到底是由A团队来负责，还是由B团队负责。不然到项目的最后，怕出现一种问题，就是有一块模糊边界的功能，A团队以为是B团队做，B团队以为是A团队做。</p><ul><li>不指定项目经理</li></ul><p>这一点应该还是不会忽视，因为涉及到立项的领导找谁了解进度，从立项领导层面，应该他第一个考虑的就是这个问题，项目经理指定谁。</p><ul><li>不规定项目成员</li></ul><p>不规定<strong>项目成员</strong>，大家都按照平常的工作内容去模糊划分，比如项目A，立张三为项目经理，张三觉得李四是属于他项目组的，但是李四又觉得他不属于张三这个项目，因为他平常的工作内容涉及到项目A，也涉及到项目B。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>任何一个事物都有两面性，立项也是一样的，优缺点尤为明显。</p><p>先说说优点吧</p><p>有项目经理这个角色的存在，项目内的事情都有一个牵头的人；</p><p>跨项目组的事情，也有一个专门去负责的人；</p><p>这有助于项目<strong>问题的快速暴露</strong>以及<strong>项目进展</strong>的推进。不然一些琐事都落在每个开发人员上，<strong>开发工作效率不高</strong>是其一，更严重的问题是具体的开发人员管理着自己的一亩三分地，很多的时候并不会全局的从项目去考虑遇到的问题，而所有问题一个节点（项目经理）经过，项目经理就能从全局出发，暴露出项目一些潜在问题。</p><p>立项最大的缺点，就是感觉团队内部会有一种<strong>隔离感</strong>。</p><p>比如说沟通的项目事宜，有时候A项目与B项目会有需要沟通和分工的功能块，期间会有一些摩擦；</p><p>还有就是项目奖金的问题，因为有一些公司是根据项目来发放项目奖金，而这也带来一个问题，项目奖金不与个人能力挂钩，而与项目挂钩。</p><p>解决上边缺点的方式，可以说是衡量管理者的水平高低的标准，怎么样增强团队的凝聚力，减少一些摩擦，提高团队效率，是管理者永恒的话题。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>这里说的注意点，也是我关于立项，关于争辩的一些思考，其实我一直觉得，<strong>每一件事情，都有界限。</strong>而我们的立项，只是把这个界限给划分出来了。</p><p>我总结的那些注意点：</p><ol><li>立项之后，项目间最小沟通单元是项目，项目内部的问题，先要内部消化之后，再上升到项目之间去沟通；</li><li>项目之间明确供需关系，项目之间相互需要什么就提供什么，不清楚项目之间的调度关系，可以组织人员开会讨论。确认提供方、提供方式、提供内容、提供时间点；</li><li>切记不要太过深入别人项目去插手别人的进度，因为每个人都有自己的工作节奏，也不要太<strong>“乐于助人”</strong>的担心别人搞不懂业务问题，因为每个人的能力不同，承诺的时间节点也是根据他的能力来给出的。作为项目负责人，管理好自己项目进度，适当的组内询问，检查好项目进度，不要让项目节奏乱，什么时间节点，做好什么事情，保持沟通；</li><li>要学会应对变化，特别是那种从0到1的产品，要以平和的心态去面对，因为各个节点有太多的不确定性。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202204031131412.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>团队管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>立项的那些事</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot优雅的集成EhCache</title>
    <link href="/java/ad129d13f02b.html"/>
    <url>/java/ad129d13f02b.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天给大家带来<code>EhCache</code>在<code>SpringBoot</code>框架下使用实战。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>EhCache</code> 是一个纯Java的<code>进程内</code>缓存框架，具有快速、精干等特点。</p><p>注意概念中的关键词<code>进程内</code>，他传递了两个<code>关键点</code>：</p><ol><li>速度快（进程内剔除了各种切换资源的损耗）；</li><li>单机适用；</li></ol><p>现在我们说缓存，迅速想到的绝对是我们的<code>Redis</code>，其实在Java生态下，有很多场景我们用<code>EhCache</code>更合理。</p><p>我这里简单的区分一下什么时候使用<code>Redis</code>，什么时候使用<code>EhCache</code>。</p><p>当我们的缓存需要多个进程（分布式）共享的时候，使用<code>Redis</code>，如果只是单机、单应用内的常见缓存，使用<code>EhCache</code>。</p><p>这篇文章不介绍太多的概念与配置，比较偏实战，老规矩，上导读图，直接进入实战环节。</p><p><img src="https://mkstatic.lianbian.net/202203152253555.png" alt="优雅的集成EhCache"></p><h2 id="SpringBoot集成实战"><a href="#SpringBoot集成实战" class="headerlink" title="SpringBoot集成实战"></a>SpringBoot集成实战</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://mkstatic.lianbian.net/202203151227457.png" alt="创建Maven项目"></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>分别引入spring-boot-starter-web、spring-boot-starter-cache、cache-api、ehcache四个包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.cache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cache-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ehcache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>记得刷新Maven引用</strong></p><p><img src="https://mkstatic.lianbian.net/202203151232645.png" alt="刷新Maven引用"></p><h3 id="配置启动类"><a href="#配置启动类" class="headerlink" title="配置启动类"></a>配置启动类</h3><p><img src="https://mkstatic.lianbian.net/202203151235166.png" alt="配置启动类"></p><h3 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h3><p>新建配置文件 <code>application.properties</code> 和 <code>ehcache.xml</code></p><p><img src="https://mkstatic.lianbian.net/202203151241566.png" alt="application.properties内容"></p><p>ehcache.xml定义一个缓存模块，指定key和value的类型，指定过期时间。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">config</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.ehcache.org/v3&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:jsr107</span>=<span class="hljs-string">&quot;http://www.ehcache.org/v3/jsr107&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.ehcache.org/v3 http://www.ehcache.org/schema/ehcache-core-3.0.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">            http://www.ehcache.org/v3/jsr107 http://www.ehcache.org/schema/ehcache-107-ext-3.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;getUserInfo&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">key-type</span>&gt;</span>java.lang.String<span class="hljs-tag">&lt;/<span class="hljs-name">key-type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value-type</span>&gt;</span>java.lang.String<span class="hljs-tag">&lt;/<span class="hljs-name">value-type</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">expiry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">ttl</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&quot;seconds&quot;</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">ttl</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">expiry</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">heap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&quot;entries&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">heap</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">offheap</span> <span class="hljs-attr">unit</span>=<span class="hljs-string">&quot;MB&quot;</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">offheap</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">cache</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>增加配置注解config文件</p><p><img src="https://mkstatic.lianbian.net/202203151243958.png" alt="通过配置注解开启EhCache"></p><h3 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h3><p>从控制器进入查找用户，查看是否多次调用<code>Service</code>的接口。</p><p><img src="https://mkstatic.lianbian.net/202203151258621.png" alt="整体代码结构"></p><p><img src="https://mkstatic.lianbian.net/202203151258300.png" alt="控制器入口"></p><p><img src="https://mkstatic.lianbian.net/202203151259724.png" alt="service定义"></p><h3 id="场景测试"><a href="#场景测试" class="headerlink" title="场景测试"></a>场景测试</h3><p>通过启动类，启动服务。</p><p>浏览器访问：<a href="http://localhost:8001/user/1">http://localhost:8001/user/1</a></p><p><img src="https://mkstatic.lianbian.net/202203151300852.png" alt="浏览器访问结果"></p><p>第一次控制台输出：</p><p><img src="https://mkstatic.lianbian.net/202203151301397.png" alt="第一次控制台输出"></p><p>之后刷新不会有变化，过了30s之后又会重新进入方法。</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>在<code>ehcache.xml</code>增加监听配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listeners</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">class</span>&gt;</span>com.baeldung.cachetest.config.CacheEventLogger<span class="hljs-tag">&lt;/<span class="hljs-name">class</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">event-firing-mode</span>&gt;</span>ASYNCHRONOUS<span class="hljs-tag">&lt;/<span class="hljs-name">event-firing-mode</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">event-ordering-mode</span>&gt;</span>UNORDERED<span class="hljs-tag">&lt;/<span class="hljs-name">event-ordering-mode</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">events-to-fire-on</span>&gt;</span>CREATED<span class="hljs-tag">&lt;/<span class="hljs-name">events-to-fire-on</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">events-to-fire-on</span>&gt;</span>EXPIRED<span class="hljs-tag">&lt;/<span class="hljs-name">events-to-fire-on</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">listeners</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="测试监听"><a href="#测试监听" class="headerlink" title="测试监听"></a>测试监听</h3><p>刷新浏览器测试</p><p><img src="https://mkstatic.lianbian.net/202203151308079.png" alt="第一次访问"></p><p><img src="https://mkstatic.lianbian.net/202203151308625.png" alt="30秒之后刷新"></p><p>注意有一个过期的事件。</p><h2 id="源代码地址"><a href="#源代码地址" class="headerlink" title="源代码地址"></a>源代码地址</h2><p>好了，<code>EhCache</code>简单的实战就到这里结束了，源码可以从 <a href="https://github.com/lianbian/EhCache"> https://github.com/lianbian/EhCache</a> 查看，微信公众号读者可以点击阅读原文。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203151318930.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ClickHouse介绍与特点</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/943175992523.html"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/943175992523.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天给大家介绍<code>ClickHouse</code>，文章整体不长，但是让大家对它有一个整体的认识。</p><blockquote><p> ClickHouse是由俄罗斯IT公司Yandex开发的一款用于联机分析处理（OLAP）的开源列式数据库。于2016年6月（Apache许可证）开源。</p></blockquote><p>老规矩，还是先上导读图，然后开始～</p><p><img src="http://mkstatic.lianbian.net/202203082153007.png" alt="ClickHouse介绍与特点"></p><h2 id="业务（数据存储）与中间件的关系"><a href="#业务（数据存储）与中间件的关系" class="headerlink" title="业务（数据存储）与中间件的关系"></a>业务（数据存储）与中间件的关系</h2><p>我们业务对数据的操作，无外乎<code>增删改查</code>，然后根据不同的业务特点，使用了不同的中间件来实现业务。</p><p>比如搜索领域（查询），我们会用有<a href="https://www.elastic.co/">Elasticsearch</a>、Solr；平常的工作中做一般的增删改查，会毫不犹豫的用<code>MySQL</code>；当要做缓存的时候，立马会想到<code>Redis</code>。</p><p>但业务总是不断变化的，当中间件满足不了具体的业务需求的时候，就会催生的新的中间件（产品）。</p><p><code>ClickHouse</code>就是为了降低大数据存储的成本，为了降低技术使用门槛而催生的一款优秀的中间件（产品）。相比<code>Hadoop</code>体系，降低了运维成本；在使用语法层面，几乎和<code>MySQL</code>没有区别，都是使用<code>DDL</code>、<code>SQL</code>这一套体系。</p><h2 id="ClickHouse适合的场景是什么"><a href="#ClickHouse适合的场景是什么" class="headerlink" title="ClickHouse适合的场景是什么"></a>ClickHouse适合的场景是什么</h2><ol><li>数据量比较大，如果一般的功能性的数据，不要用<code>ClickHouse</code>，比如做一个OA人事管理系统，这就是功能性的系统；</li><li>静态数据，比如工业设备产生的追溯数据；</li><li>不需要全文检索，需要全文检索一般的方案是在<code>ClickHouse</code>上层添加<code>ES</code>中间件；</li></ol><p>之前准备用<code>ES</code>来实现我的业务，后来对<code>ClickHouse</code>有了一定的了解之后，发现<code>ClickHouse</code>更适用。</p><p>我的业务场景：搜集工业设备上报的实验数据，在必要的时候要进行数据追溯（无全文检索），有一些实时数据也需要及时展示。</p><p><code>ES</code>是出了名的吃服务器的，如果<code>ClickHouse</code>满足你的业务，尽可能用<code>ClickHouse</code>；</p><p>网上有人做了对比，有兴趣的可以看一看。</p><p><a href="https://zhuanlan.zhihu.com/p/353296392">Elasticsearch和Clickhouse基本查询对比</a></p><h2 id="一些术语的解释"><a href="#一些术语的解释" class="headerlink" title="一些术语的解释"></a>一些术语的解释</h2><ol><li><p>宽表</p><p>包含了很多个列的大表，“宽”字很形象；</p></li><li><p>OLAP&amp;OLTP</p><p>在线事务处理（Online Transaction Processing、OLTP）和在线分析处理（Online Analytical Processing、OLAP）是数据库最常见的两种场景，这两种场景不是唯二的两种，从中衍生出来的还有混合事务分析处理（Hybrid Transactional/Analytical Processing、HTAP）3等概念。</p><p>在线事务处理（OLTP）是最常见的场景，在线服务需要为用户实时提供服务，提供服务的过程中可能要查询或者创建一些记录；</p><p>在线分析处理（OLAP）的场景需要批量处理用户数据，数据分析师会根据用户产生的数据分析用户行为和画像、产出报表和模型。</p></li><li><p>列式存储</p></li></ol><p>推荐一篇我写的文章，很清晰的讲清楚了 <a href="https://mp.weixin.qq.com/s/AHuzT_k2XhF5HVEACOl1-w">什么是列式存储</a></p><h2 id="学习资料的推荐"><a href="#学习资料的推荐" class="headerlink" title="学习资料的推荐"></a>学习资料的推荐</h2><ol><li><p><a href="https://clickhouse.com/docs/en/">ClickHouse官方</a> </p><p>推荐英文版，虽然有中文版，但是有很多代码示例，只有英文版本有。</p></li><li><p><a href="https://www.bilibili.com/video/BV1Yh411z7os?p=1">尚硅谷视频</a></p><p>整体<code>64</code>个视频，用1.5倍数，配上虚拟机边观看，边实战一遍，大概2天完整的时间能够搞定。</p></li><li><p><a href="https://www.lianbian.net/categories/clickhouse/">连边ClickHouse</a></p><p>我整理的关于ClickHouse一些文章，前期理念与实战，后期也会更新线上遇到的问题。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天这篇文章写到这里就结束了，在我们平常工作中，一定要注意仔细剖析业务，选择合适的中间件来实现业务，做到事半功倍的效果。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>可以关注<code>订阅号@连边</code>不错过精彩文章</p><p><img src="http://mkstatic.lianbian.net/202203082207503.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clickhouse</tag>
      
      <tag>技术选型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是列式存储？</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/d6d6610971f1.html"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/d6d6610971f1.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边，这是我的第<code>36</code>篇原创文章。</p><p>今天这篇文章从一个简单的表格开始来给大家讲列式存储。</p><p>还是老规矩，先上导读图，然后开始～</p><p><img src="http://mkstatic.lianbian.net/202203032332940.png" alt="什么是列式存储"></p><h2 id="从一个表格说起"><a href="#从一个表格说起" class="headerlink" title="从一个表格说起"></a>从一个表格说起</h2><p>要讲列式存储，首先要讲表格，我们平常统计数据用Excel，就是最常见的表格。</p><p>如下表格，我们统计了学生的基本信息：</p><table><thead><tr><th align="center">学号</th><th align="center">姓名</th><th align="center">性别</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="center">001</td><td align="center">张三</td><td align="center">男</td><td align="center">60</td></tr><tr><td align="center">002</td><td align="center">李四</td><td align="center">男</td><td align="center">70</td></tr><tr><td align="center">003</td><td align="center">王五</td><td align="center">男</td><td align="center">80</td></tr></tbody></table><p>行、列组成了我们看到的表格。而我们说的列式存储，是与行式存储是相对而言的。</p><p>除开表头（学号、姓名、性别、成绩）这一行，我们看其他的三行数据。假如现在我说：“我们要把学生的基础信息以行来分开保存到记事本里边”，你下意识的会不会这么做？</p><p>复制、粘贴第一行保存为记事本 《张三.txt》</p><table><thead><tr><th align="center">001</th><th align="center">张三</th><th align="center">男</th><th align="center">60</th></tr></thead></table><p>复制、粘贴第二行保存到记事本 《李四.txt》</p><table><thead><tr><th align="center">002</th><th align="center">李四</th><th align="center">男</th><th align="center">70</th></tr></thead></table><p>复制、粘贴第三行保存到记事本 《王五.txt》</p><table><thead><tr><th align="center">003</th><th align="center">王五</th><th align="center">男</th><th align="center">80</th></tr></thead></table><p>其实你这个下意识的存储方式，就是我们的行式存储。</p><p>抽象成存储的数据结构，可以长这样子：</p><p><img src="http://mkstatic.lianbian.net/202203032308971.png" alt="行式存储数据结构"></p><p>而我们今天的主角，列式存储会是什么样子呢？相信你也非常清楚了吧？</p><p>复制、粘贴第一列保存到记事本 《学号.txt》</p><table><thead><tr><th align="center">学号</th></tr></thead><tbody><tr><td align="center">001</td></tr><tr><td align="center">002</td></tr><tr><td align="center">003</td></tr></tbody></table><p>复制、粘贴第一列保存到记事本 《姓名.txt》</p><table><thead><tr><th align="center">姓名</th></tr></thead><tbody><tr><td align="center">张三</td></tr><tr><td align="center">李四</td></tr><tr><td align="center">王五</td></tr></tbody></table><p>复制、粘贴第一列保存到记事本 《性别.txt》</p><table><thead><tr><th align="center">性别</th></tr></thead><tbody><tr><td align="center">男</td></tr><tr><td align="center">男</td></tr><tr><td align="center">男</td></tr></tbody></table><p>复制、粘贴第一列保存到记事本 《成绩.txt》</p><table><thead><tr><th align="center">成绩</th></tr></thead><tbody><tr><td align="center">60</td></tr><tr><td align="center">70</td></tr><tr><td align="center">80</td></tr></tbody></table><p>抽象成存储的数据结构，可以长这样子：</p><p><img src="http://mkstatic.lianbian.net/202203032305135.png" alt="列式存储"></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>上边如果弄清楚了，我们再来聊一聊为什么列式存储会突然出现在我们面前？相比我们的行式存储，它有什么优势呢？</p><p>其实从马云早些年喊出大数据是将来的石油开始，可见大数据在很多公司的地位，一些中小型公司也慢慢的重视起客户的数据分析一系列举措来提高成交量，数字化成为很多公司的战略。</p><p>而大数据、数字化这些战略的背后，我们就需要有大数据的存储容器，即数据库。</p><p>最开始，我们会一股脑的放在我们的MySQL里边，但是随着时间的推移，数据量越来越大，会发现很多统计查询会越来越慢，最后查询分析数据的速度，满足不了业务的需求了。</p><p>怎么办？查询慢，赶快建索引啊！</p><p>还不行又怎么办？彻底分析需求，还是得从数据结构上想办法。</p><p>需求：求平均成绩</p><p>计算方式：(60+70+80)/3 = 70</p><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(`成绩`) <span class="hljs-keyword">FROM</span> `Students`;<br></code></pre></td></tr></table></figure><p>还是以上边的表格来说，如果我是行式存储，就是存储三个文件《张三.txt》、《李四.txt》、《王五.txt》，如果要拿出他们各自的成绩，我需要对他们三个文件去进行文件打开、获取成绩、文件关闭；获取到分别的成绩之后，然后进行平均值计算，这就消耗了三次IO。</p><p>而如果我们以列式存储的呢？我是要求<code>成绩</code>这一列的平均值，我直接从《成绩.txt》这个文件里边拿出数据，再计算平均值就好了。</p><p>感觉到他们的优势了吗？</p><p>这也是列式存储的（最大）优势，即：</p><p><strong>快速读取特定列。</strong></p><p>如果从事大数据分析行业的朋友，想想你的一些需求，是不是大多数都是计算某列数据的值？</p><p>继续讲列式存储的另外一个好处，<strong>连续的空间利于算法压缩</strong></p><p>因为列式存储将同一列的数据存储在一起，所以使用压缩算法可以得到更高的压缩率，减少存储占用的磁盘空间。压缩算法的基本原理其实很简单，它使用基于特定规则的数据表示原数据，如下所示的字符串中包含连续的相同字符，我们使用最符合直觉的压缩算法就可以减少字符串的长度：</p><p><img src="http://mkstatic.lianbian.net/202203032312839.png" alt="重复数据压缩后的列式存储"></p><p>以上就是把“男男男“，存储成了”男3“，表示重复的”男“这个字符，有3个。同理，如果我们数据量大了，有很多分数相同的，也可以进行同样的压缩。</p><h2 id="不是银弹"><a href="#不是银弹" class="headerlink" title="不是银弹"></a>不是银弹</h2><p>列式存储也并非银弹（比喻什么问题都能解决的方式方法），也有他的缺点。</p><p>我们开动脑筋的想一想，我举一个例子：</p><p>列式存储是连续空间，连续空间就和我们的数组结构一样，虽然查询的速度是快了，但是修改（增删改）的速度就要各种挪动元素了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从一个简单的表格出发，讲了行式存储和列式存储，最后推出了列式存储的两个优点：</p><ol><li>快速读取特定列；</li><li>连续的空间利于算法压缩；</li></ol><p>然后也说了，列式存储并非银弹，只是在不同的诉求下，有不同的方案取舍。</p><p>推荐文章：</p><p><a href="https://draveness.me/whys-the-design-olap-column-oriented/">https://draveness.me/whys-the-design-olap-column-oriented/</a></p><p><a href="https://juejin.cn/post/6844904118872440840">https://juejin.cn/post/6844904118872440840</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clickhouse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis 插件原理与实战</title>
    <link href="/java/11ea8ad5840b.html"/>
    <url>/java/11ea8ad5840b.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是连边。</p><p>最近是一直在整理<a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzA4MjUzODc0OQ==&hid=2&sn=2004fd1d3f6bca21c4cd4783a6be7fb2&scene=18#wechat_redirect">#面试精选</a>，如果是准备最近跳槽的同学，可以点击<a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzA4MjUzODc0OQ==&hid=2&sn=2004fd1d3f6bca21c4cd4783a6be7fb2&scene=18#wechat_redirect">#面试精选</a>查看文章列表。</p><p>今天给大家带来MyBatis面试系列的最后一篇《MyBatis插件原理与实战》。</p><p>该系列总共4篇，4篇文章涵盖了95%的MyBatis面试题。</p><ol><li><a href="https://mp.weixin.qq.com/s/Oz7fNEIKCE5axq53vdsPtA">MyBatis 常见面试题总结</a> （整体的开胃菜，快问快答系列，当作自己知识点的查漏补缺）；</li><li><a href="https://mp.weixin.qq.com/s/L2rYzOCl7pdEce1ztN0zDg">MyBatis 动态代理详解</a> （针对动态代码的详细解读，从Java普通代理讲起，有原理，有实战）；</li><li><a href="https://mp.weixin.qq.com/s/QH7p7YZIqGuMpSKF96jQMQ">MyBatis 缓存工作原理</a></li><li>MyBatis插件原理与实战 （本篇）</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在做新项目，基于若依（前后端分离版本）做的，他也使用了常用的分页插件<code>PageHelper</code>。</p><p>老规矩，今天文章还是分三步走，先上<strong>文章导读</strong>，然后讲<strong>原理</strong>，最后讲解<strong>源码案例</strong>。</p><p>最后达到的效果就是希望读者朋友们在看完我写的这篇文章后，能够<strong>秒懂别人写的MyBatis插件</strong>并且<strong>能够开发出自己的MyBatis的插件</strong>。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p><img src="http://mkstatic.lianbian.net/202201242321108.png" alt="MyBatis 插件原理与实战"></p><h2 id="什么是插件？"><a href="#什么是插件？" class="headerlink" title="什么是插件？"></a>什么是插件？</h2><p>插件就是在具体的<strong>执行流程</strong>插一脚（触发点、拦截器）来实现具体的功能。</p><p>一般插件会对<strong>执行流程</strong>中的上下文有依赖，抽象的说，我们也可以把MyBatis看作是JDBC的<strong>插件</strong>，只是功能越来来多，越来越强大，最后我们给了他一个新名字，叫做<strong>框架</strong>。</p><p>不管怎样，JDBC的那一套还是不会变的，只是做了抽象、封装、归类等。</p><p>要想知道插件的原理，首先就要对它的执行流程有一定的把控。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>前边我们讲到，MyBatis是对JDBC的抽象、封装。</p><p>我们首先来回顾一下JDBC的执行流程。</p><h3 id="JDBC执行流程"><a href="#JDBC执行流程" class="headerlink" title="JDBC执行流程"></a>JDBC执行流程</h3><ol><li>注册驱动；</li><li>获取Connection连接；</li><li>执行预编译；</li><li>执行SQL；</li><li>封装结果集；</li><li>释放资源；</li></ol><p><strong>给段伪代码通透理解下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注册驱动</span><br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br><span class="hljs-comment">// 获取链接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, username, password);<br><span class="hljs-comment">// 执行预编译</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> con.createStatement();<br><span class="hljs-comment">// 执行SQL</span><br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery(<span class="hljs-string">&quot;SELECT * FROM ...&quot;</span>);<br><span class="hljs-comment">// 封装结果</span><br><span class="hljs-keyword">while</span> (rs.next()) &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>  <span class="hljs-type">String</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> rs.getString(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此方法比较高效</span><br>&#125;<br><span class="hljs-comment">// 释放资源</span><br><span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 关闭记录集</span><br><br>&#125;<br><span class="hljs-keyword">if</span> (stmt != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 关闭声明</span><br><br>&#125;<br><span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 关闭连接对象</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>上边的代码是不是很熟悉，我相信每个入门写Java代码的人，都写过这段代码。</p><p>紧接着，我们继续来了解MyBatis的执行流程。</p><h3 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h3><ol><li><p>读取MyBatis的核心配置文件；</p></li><li><p>加载映射文件；</p></li><li><p>构造会话工厂获取SqlSessionFactory；</p></li><li><p>创建会话对象SqlSession；</p></li><li><p>Executor执行器；</p></li><li><p>MappedStatement对象；</p></li><li><p>输入参数映射；</p></li><li><p>封装结果集；</p></li></ol><p>上边的文字可能不太好理解，我这里也画一幅执行流程图，来方便理解。</p><p><img src="http://mkstatic.lianbian.net/202201242305818.png" alt="MyBatis执行流程"></p><p>有没有觉得MyBatis的执行流程和JDBC的执行流程主干也差不多，只是在主干过程中，把一些配置（mybatis-config.xml）、常用的定义文件单独抽离出来（mapper.xml）和一些附带扩展性的<strong>拦截点</strong>抽离了出来。</p><p>下面着重讲一讲我们的<strong>拦截点</strong>，因为插件就是基于我们的<strong>拦截点</strong>来做的扩展。</p><h2 id="拦截点"><a href="#拦截点" class="headerlink" title="拦截点"></a>拦截点</h2><p>结合上边的MyBatis执行流程，看下图的各个拦截点：</p><p><img src="http://mkstatic.lianbian.net/202201242311617.png" alt="MyBatis拦截点"></p><p>文字描述，MyBatis允许使用插件来<strong>拦截的方法调用</strong>包括：</p><ol><li><p>Executor：</p><p>拦截执行器的方法 (<strong>update, query, flushStatements, commit, rollback,getTransaction, close, isClosed</strong>)，Mybatis的内部执行器，它负责调用StatementHandler操作数据库，并把结果集通过 ResultSetHandler进行自动映射，另外，他还处理了二级缓存的操作。从这里可以看出，我们也是可以通过插件来实现自定义的二级缓存的；</p></li><li><p>ParameterHandler：</p><p>拦截参数的处理 (<strong>getParameterObject, setParameters</strong>) ，Mybatis直接和数据库执行sql脚本的对象。另外它也实现了Mybatis的一级缓存。这里，我们可以使用插件来实现对一级缓存的操作(禁用等等)；</p></li><li><p>ResultSetHandler：</p><p>拦截结果集的处理 (<strong>handleResultSets, handleOutputParameters</strong>) ，Mybatis实现Sql入参设置的对象。插件可以改变我们Sql的参数默认设置；</p></li><li><p>StatementHandler：</p><p>拦截Sql语法构建的处理 (<strong>prepare, parameterize, batch, update, query</strong>) ，Mybatis把ResultSet集合映射成POJO的接口对象。我们可以定义插件对Mybatis的结果集自动映射进行修改。</p></li></ol><h2 id="拦截器为什么能够拦截"><a href="#拦截器为什么能够拦截" class="headerlink" title="拦截器为什么能够拦截"></a>拦截器为什么能够拦截</h2><p><code>org.apache.ibatis.session.Configuration</code>是在MyBatis初始化配置的类。</p><p>其中的<code>newParameterHandler</code>、<code>newResultSetHandler</code>、<code>newStatementHandler</code>、<code>newExecutor</code>这几个方法在创建指定的对象（newParameterHandler创建ParameterHandler、newResultSetHandler创建ResultSetHandler、newStatementHandler创建StatementHandler、newExecutor创建Executor）对象的时候，都会调用一个统一的方法：</p><p><img src="http://mkstatic.lianbian.net/202201242215206.png" alt="创建对象"></p><p>这4个方法实例化了对应的对象之后，都会调用interceptorChain的pluginAll方法，那么下面我们在来看pluginAll干了什么。</p><p>包路径：<code>org.apache.ibatis.plugin.InterceptorChain</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">pluginAll</span><span class="hljs-params">(Object target)</span> &#123;<br>        Interceptor interceptor;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.interceptors.iterator(); var2.hasNext(); target = interceptor.plugin(target)) &#123;<br>            interceptor = (Interceptor)var2.next();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br></code></pre></td></tr></table></figure><p>原来这个pluginAll方法就是遍历所有的拦截器，然后顺序执行我们插件的plugin方法,一层一层返回我们原对象(Executor/ParameterHandler/ResultSetHander/StatementHandler)的代理对象。当我们调用四大接口对象的方法时候，实际上是调用代理对象的响应方法，代理对象又会调用四大接口对象的实例。</p><p>这里我们看到所有的拦截器Interceptor，其实它和我们平常写代码一样，也是多态的利用，存在一个拦截器Interceptor接口，<strong>我们在实现插件的时候，也实现这个接口，就会被调用。</strong></p><h2 id="Interceptor接口"><a href="#Interceptor接口" class="headerlink" title="Interceptor接口"></a>Interceptor接口</h2><p>包路径：<code>org.apache.ibatis.plugin</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation var1)</span> <span class="hljs-keyword">throws</span> Throwable;<br><br>    <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口只声明了三个方法：</p><ol><li>setProperties方法是在Mybatis进行配置插件的时候可以配置自定义相关属性，即：接口实现对象的参数配置；</li><li>plugin方法是插件用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理，可以决定是否要进行拦截进而决定要返回一个什么样的目标对象，官方提供了示例：return Plugin.wrap(target, this)；</li><li>intercept方法就是要进行拦截的时候要执行的方法；</li></ol><h2 id="编写简单的MyBatis插件"><a href="#编写简单的MyBatis插件" class="headerlink" title="编写简单的MyBatis插件"></a>编写简单的MyBatis插件</h2><p><strong>注：MyBatis默认没有一个拦截器接口的实现类，开发者可以实现符合自己需求的拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type= Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class,Object.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamplePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">return</span> invocation.proceed();<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>全局xml配置（实例化bean）</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;org.format.mybatis.cache.interceptor.ExamplePlugin&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>这个拦截器拦截Executor接口的update方法（其实也就是SqlSession的新增，删除，修改操作），所有执行executor的update方法都会被该拦截器拦截到，就在里边做相对应的逻辑处理就可以了。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天这篇文章到这里结束了，讲解了什么是插件首先需要了解执行流程，然后回顾我们的JDBC流程来推导出MyBatis的执行流程，通过初始化的<code>org.apache.ibatis.session.Configuration</code>为切入点，跟踪到interceptorChain的pluginAll方法；最后通过一个简单的插件来实操了一波。</p><p>参考链接：</p><p><a href="https://zhuanlan.zhihu.com/p/150008843">https://zhuanlan.zhihu.com/p/150008843</a></p><p><a href="https://blog.csdn.net/weixin_44046437/article/details/100523028">https://blog.csdn.net/weixin_44046437/article/details/100523028</a></p><p><a href="https://blog.csdn.net/weixin_44046437/article/details/100526643">https://blog.csdn.net/weixin_44046437/article/details/100526643</a></p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203160755986.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么填入pom依赖后，我们就能使用其类对象</title>
    <link href="/java/e16496b26fc9.html"/>
    <url>/java/e16496b26fc9.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天给大家一个腾讯的真实面试题。</p><p>面试官：“在SpringBoot中开发，为什么我们在填入pom依赖以后，就能使用其对象？”</p><p>今天这篇文章呢，我就来给大家分析这个问题。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p><img src="http://mkstatic.lianbian.net/202112282331074.png" alt="自动配置"></p><h2 id="引用流程"><a href="#引用流程" class="headerlink" title="引用流程"></a>引用流程</h2><p>当我们在<code>pom.xml</code>文件中填写引入一个依赖以后，我们的包控制器（maven、gradle）会从<code>settings.xml</code>配置的镜像地址拉取<code>jar</code>到我们本地（idea中下边的刷新按钮执行拉取），这个时候我们看到的现象就是<code>jar</code>拉取到本地不用实例化就能直接拿来用了。</p><p><img src="http://mkstatic.lianbian.net/202112282135069.png" alt="刷新引用"></p><p>面试官就是问这一点，<strong>对象我们没有注入到Spring容器中，怎么就能用了？</strong></p><h2 id="正常的逻辑"><a href="#正常的逻辑" class="headerlink" title="正常的逻辑"></a>正常的逻辑</h2><p>先抛开这个问题，想想我们平常是怎样把一个<code>bean</code>对象（创建）交给Spring容器管理的？</p><p>很容易想到两种方式对不对？通过<code>xml配置</code>或者通过<code>@Configuration注解</code>。</p><p><strong>xml配置创建bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;apple&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;first.Apple&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注解创建bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerConfig</span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Docket <span class="hljs-title function_">createRestApi</span><span class="hljs-params">()</span><br>    &#123;<br>      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那我们就来想一想，是不是在SpringBoot启动的时候，帮我们把这个事情自动给做了？</p><p>这里也可以想到我们Spring常说到的一句话，<strong>约定大于配置</strong>。</p><p>那我们去找找看看SpringBoot有没有帮我们做这件事情吧～</p><h2 id="从启动过程分析"><a href="#从启动过程分析" class="headerlink" title="从启动过程分析"></a>从启动过程分析</h2><p>如果你还不熟悉SpringBoot启动做了什么，可以看一看我的上一篇文章 - <a href="https://mp.weixin.qq.com/s/RqB_A8_yCRhFA1Vz8W47oA">SpringBoot启动都做了什么？看完就懂了！</a></p><p>我们上篇分析了<code>@SpringBootApplication</code>是一个合成注解，分为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan</span><br></code></pre></td></tr></table></figure><p>这里我们着重来看<code>@EnableAutoConfiguration</code>具体做了什么事情。</p><p>依次点击注解：<code>@SpringBootApplication</code> -&gt; <code>@EnableAutoConfiguration</code> -&gt; <code>@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code></p><p>点击 <code>AutoConfigurationImportSelector.class</code></p><p>这里我用文字来详细描述该过程：</p><ol><li>利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件；</li><li>调用List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类；</li><li>利用工厂加载 Map&lt;String, List<String>&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件；</li><li>从META-INF/spring.factories位置来加载一个文件。默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件，spring-boot-autoconfigure-2.5.6.RELEASE.jar包里面也有META-INF/spring.factories</li></ol><p>虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration<br>按照条件装配规则（<code>@Conditional</code>），最终会<strong>按需配置</strong>。</p><h2 id="mybatis实例讲解"><a href="#mybatis实例讲解" class="headerlink" title="mybatis实例讲解"></a>mybatis实例讲解</h2><p><img src="http://mkstatic.lianbian.net/202112282323390.png" alt="mybatis-spring-boot-autoconfigure"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 按需加载：找得到 SqlSessionFactory.class SqlSessionFactoryBean.class类，我这个自动配置才生效。</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span><br><span class="hljs-meta">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="autoconfigure从哪里引入的？"><a href="#autoconfigure从哪里引入的？" class="headerlink" title="autoconfigure从哪里引入的？"></a>autoconfigure从哪里引入的？</h2><p>我在整个过程中，就是引入了这个依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringBoot Web容器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><code>starter</code>的题外话：</strong>可以把<code>starter</code>看作是<code>dependency</code>的套娃。</p><p>spring-boot-starter-web包含的<code>dependency</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>里边还能循环嵌套～，通过一层一层的点击，找到<strong>spring-boot-autoconfigure</strong> 是自动配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到开始面试题的答案，其实有个专业名词，就是<strong>自动配置</strong>。</p><p><strong>由于我们springboot引入了<code>spring-boot-autoconfigure</code>的jar包，而在SpringBoot启动的时候自动配置注解会扫描jar包META-INF/spring.factories位置的文件，然后按需加载（通过注解实现）<code>xxxxxAutoConfiguration</code>，从而通过自动加载来实现我们看到的效果。</strong></p><h3 id="推荐资料"><a href="#推荐资料" class="headerlink" title="推荐资料"></a>推荐资料</h3><p>最后在这里特别推荐<strong>尚硅谷雷神</strong>的讲SpringBoot2的视频，讲得很全面也很细致，非常推荐，有时间的朋友，可以系统的，认真的卷一下。</p><p>视频地址：<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a></p><p>对应的笔记地址：<a href="https://www.yuque.com/atguigu/springboot/qb7hy2">https://www.yuque.com/atguigu/springboot/qb7hy2</a></p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203152305384.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java 面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win下部署多个MySQL数据库实例</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/955c852efe57.html"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/955c852efe57.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>当你们考虑项目并发的时候，我在部署环境，当你们在纠结使用<code>ArrayList</code>还是<code>LinkedArrayList</code>的时候，我还是在部署环境。所以啊，<strong>技术不止境，我在部环境。</strong></p><p>今天这篇文章缕一下在同一台服务器上部署多个<code>MySQL</code>实例的操作过程，就是一篇工作手记，没有高深的内容，希望需要用到的朋友，按照这篇文章操作，能够<strong>不踩坑</strong>的把实例部署好。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p><img src="http://mkstatic.lianbian.net/202112062123673.png" alt="Win下部署多个MySQL数据库实例"></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>我这里以安装<code>5.7.17</code>版本，可以到官网下载对应的版本。</p><p><strong>如果配置了<code>mysql</code>相关的环境变量，请删除原来的环境变量，再进行安装。</strong></p><h2 id="解压-amp-amp-目录"><a href="#解压-amp-amp-目录" class="headerlink" title="解压&amp;&amp;目录"></a>解压&amp;&amp;目录</h2><p>解压之后，目录如下：</p><p><img src="http://mkstatic.lianbian.net/202112061915202.png" alt="MySQL目录"></p><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="重命名解压文件夹"><a href="#重命名解压文件夹" class="headerlink" title="重命名解压文件夹"></a>重命名解压文件夹</h3><p>把<code>mysql5.7.17-winx64</code>重命名成<code>mysql5.7.17-3308</code></p><h3 id="配置端口"><a href="#配置端口" class="headerlink" title="配置端口"></a>配置端口</h3><p><strong>切换到解压文件夹</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd softs/mysql5.7.17-3308<br></code></pre></td></tr></table></figure><p>找到<code>my-default.ini</code>并重命名配置文件：<code>my-default.ini -&gt; my.ini</code></p><p>配置端口节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">prot = .....</span><br>prot = 3306<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/202112061946359.png" alt="修改端口"></p><h3 id="以管理员方式运行命令行窗口"><a href="#以管理员方式运行命令行窗口" class="headerlink" title="以管理员方式运行命令行窗口"></a>以<strong>管理员</strong>方式运行命令行窗口</h3><p><strong>如果配置了<code>mysql</code>相关的环境变量，请删除原来的环境变量，再进行安装。</strong></p><p>也可以使用快捷键，<code>Win + R</code>，！！注意要以<strong>管理员的身份运行命令行窗口</strong></p><p><strong>进入到 bin 目录</strong></p><p><code>cd bin</code></p><p><strong>初始化 | 会在数据库的根目录上创建 data 文件夹</strong></p><p><code>mysqld --initialize --console</code></p><p><strong>查看默认密码</strong></p><p><img src="http://mkstatic.lianbian.net/202112061950528.png" alt="默认密码"></p><p><strong>安装服务 | mysqld –install 服务名称</strong></p><p><code>mysqld --install MySQL5.7-3308</code></p><p><strong>启动服务</strong></p><p><code>net start MySQL5.7-3308</code></p><p><img src="http://mkstatic.lianbian.net/202112061958557.png" alt="注册&amp;启动服务"></p><p>至此，如果一切正常，其实就是这三步，就安装好了一个MySQL数据库实例。</p><p><strong>查看服务</strong></p><p>命令行执行：<code>services.msc</code></p><p><img src="http://mkstatic.lianbian.net/202112062015514.png" alt="查看服务"></p><p>我们接着测试该数据库的其可用性。</p><h3 id="测试链接"><a href="#测试链接" class="headerlink" title="测试链接"></a>测试链接</h3><p>命令行窗口和客户端工具连接都可以。</p><p><code>mysql -uroot -P3308 -p</code></p><p>密码输入在<code>mysqld --initialize --console</code>步骤生成的密码。</p><p><img src="http://mkstatic.lianbian.net/202112062117241.png" alt="默认密码"></p><p>如果用客户端连接这个时候会有一个警告：<code>Your password has expired. To log in you must  change it using a client that supports expired passwords.</code></p><p>翻译过来大概意思就是：“您的密码已过期。要登录，您必须使用支持过期密码的客户端更改它”</p><p>解决办法：root权限登录mysql：<code>mysql -uroot -p</code></p><p>登录成功后修改密码：<code>set password=password(&#39;root&#39;);</code></p><h3 id="安装第二个数据库"><a href="#安装第二个数据库" class="headerlink" title="安装第二个数据库"></a>安装第二个数据库</h3><p>重复以上的步骤，保证端口不被占用，不重复就可以了。</p><p>这里不再赘述，有问题的可以欢迎加我微信交流。</p><h3 id="一些常用的其他命令"><a href="#一些常用的其他命令" class="headerlink" title="一些常用的其他命令"></a>一些常用的其他命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 根据端口号找PID</span></span><br>netstat -aon|findstr &quot;3308&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 查看指定PID</span></span><br>tasklist|findstr &quot;9088&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 停止服务</span></span><br>net stop MySQL5.7-3306<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 卸载服务（只有在服务停止的时候才能卸载）</span></span><br>mysqld remove MySQL5.7-3306<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一篇手记，没有啥好总结的，就是希望大家伙少踩坑。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不重启服务进行功能开发，热部署</title>
    <link href="/java/8558ecaea2fb.html"/>
    <url>/java/8558ecaea2fb.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>之前在写<a href="https://mp.weixin.qq.com/s/Lw9kQZEl5eTMsKxNSNMVww">不重启JVM替换掉已经加载的类</a>，有读者朋友要我写一篇关于开发环境不重启服务也能进行功能开发的文章，我呢，最近接手了一个项目，启动项目服务需要<code>10分钟</code>，在项目启动速度无法优化的前提下，为了节约时间摸鱼，为了能敲更多的<code>bug</code>，为了能掉更多的头发，所以呢，机缘巧合，开整。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p><img src="http://mkstatic.lianbian.net/202112012347413.png" alt="不重启服务进行功能开发"></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><code>Spring Boot 2.3.2 RELEASE</code> +<code>Mybatis-plus 3.2.2</code></p><p>不要看着这个环境不适合就跑了，不要怕，是通用的，只是我是在这种环境下写的<code>JavaHotDevbugTool</code>这个工具demo。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>我们在日常开发过程中，改得最多的无非是<code>控制器</code>、<code>接口层</code>，还是就是<code>mapper xml</code>；不管我们修改一个字母，还是更细微的改动，都需要重启服务，这个重启是重启整个<code>Spring</code>容器，粒度相当大，当我们应用包含了较多的<code>bean</code>的时候，重启的时候还是挺久的，像我现在接手的这个项目，就是<code>10分钟</code>，在开发调试阶段，这个时间是无法接受的，自然的就想着从两方面下手，一种方式是缩短启动时间，还有一种就是热部署（在不重启服务的前提下进行开发）。我选择了后者，因为前者需要对业务太大入侵性太大。</p><p><strong>而热部署就很容易想到能不能增量部署，即没有变更的文件，我们就不去重新加载，只加载有变更的文件。</strong></p><p>想想我们日常开发当中，改得最多的就是java文件和mybatis的xml文件，所以这篇文章就是要解决两个问题，<strong>java文件和xml文件的热更新问题</strong>。</p><h2 id="Java文件热更新"><a href="#Java文件热更新" class="headerlink" title="Java文件热更新"></a>Java文件热更新</h2><h3 id="DevTools介绍"><a href="#DevTools介绍" class="headerlink" title="DevTools介绍"></a>DevTools介绍</h3><p>spring为开发者提供了一个名为<code>spring-boot-devtools</code>的模块来使Spring Boot应用支持热部署，提高开发者的开发效率，无需手动重启Spring Boot应用。原理是使用了两个<code>ClassLoader</code>，一个<code>Classloader</code>加载那些不会改变的类（第三方Jar包），另一个<code>ClassLoader</code>加载会更改的类，称为<code>restart ClassLoader</code>,这样在有代码更改的时候，原来的<code>restart ClassLoader</code> 被丢弃，重新创建一个<code>restart ClassLoader</code>，由于需要加载的类相比较少，所以实现了较快的重启时间。</p><h3 id="引用包"><a href="#引用包" class="headerlink" title="引用包"></a>引用包</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/202111251943777.png" alt="配置pom并引用"></p><h3 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h3><p><img src="http://mkstatic.lianbian.net/202111251949436.png" alt="重启服务"></p><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p><strong>手动编译</strong>快捷键编译（ctrl + f9），网络上有很多帖子，说<code>idea</code>有一个保存的时候，自动编译功能，我几番设置没有成功，后来选择了手动编译，一个字：稳。</p><p><strong>编译的本质</strong>可以简单的理解为是重新生成我们target文件下边的.class文件。</p><p><img src="http://mkstatic.lianbian.net/202111251940342.png" alt="编译进度条"></p><p>如果有类热更新了，会有相应的提示，如下图：</p><p><img src="http://mkstatic.lianbian.net/202111251950958.png" alt="热更新代码"></p><p><img src="http://mkstatic.lianbian.net/202111251951055.png" alt="reload成功提示"></p><p>可以更深入的进行打断点进行调试，都是有效果的，这里需要注意的一点：</p><p><strong>不是java文件的所有地方都有效果，像新增文件、修改注解参数之类的是无效果的，和他的加载方式有关系，新增控制器什么的，只能重启服务。</strong></p><p>解决了Java文件的热更新，我们继续看另外一个高频更改的<code>mapper xml</code>文件的热更新。</p><h2 id="Mapper-XML文件热更新"><a href="#Mapper-XML文件热更新" class="headerlink" title="Mapper XML文件热更新"></a>Mapper XML文件热更新</h2><p>在<code>Mybatis</code>在<code>3.0</code>以前的版本，有一个<code>MybatisMapperRefresh</code>类，但是在<code>3.0</code>的版本移除改功能了，这也是为什么下边的配置无效的原因。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">mybatis-plus:<br>  global-config:<br>    #刷新mapper 调试神器<br>    refresh-mapper: true<br></code></pre></td></tr></table></figure><p>我使用的<code>3.3.2</code>版本，因为我是在<code>spring boot</code>环境中使用，所以加上如下引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol><li>找到所有的<code>mapper xml</code>路径；</li><li>启动线程监听；</li><li>重新加载<code>xml</code>文件；</li></ol><h3 id="XmlMapperReload类"><a href="#XmlMapperReload类" class="headerlink" title="XmlMapperReload类"></a>XmlMapperReload类</h3><p><strong>定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XmlMapperReload 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlMapperReload</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XmlMapperReload 构造方法</span><br><span class="hljs-comment">// mapperLocations：mapper xml 路径</span><br><span class="hljs-comment">// checkSeconds 多久检测一次</span><br><span class="hljs-comment">// enabled 是否开启</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">XmlMapperReload</span><span class="hljs-params">(Resource[] mapperLocations, SqlSessionFactory sqlSessionFactory,<span class="hljs-type">int</span> checkSeconds, <span class="hljs-type">boolean</span> enabled)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>开启监听</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="XmlMapperReload-Bean-Config"><a href="#XmlMapperReload-Bean-Config" class="headerlink" title="XmlMapperReload Bean Config"></a>XmlMapperReload Bean Config</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XmlMapperReloadConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Profile(&quot;dev&quot;)</span><br>    <span class="hljs-keyword">public</span> XmlMapperReload <span class="hljs-title function_">xmlMapperReload</span><span class="hljs-params">(SqlSessionFactory sqlSessionFactory, MybatisPlusProperties mybatisPlusProperties)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlMapperReload</span>(mybatisPlusProperties.resolveMapperLocations(), sqlSessionFactory, <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>完整的源码，放在github上边了，可以拿来直接跑起来的项目，连接地址：</strong></p><p><a href="https://github.com/lianbian/JavaHotDevbugTool">https://github.com/lianbian/JavaHotDevbugTool</a></p><h3 id="重启服务-1"><a href="#重启服务-1" class="headerlink" title="重启服务"></a>重启服务</h3><p><img src="http://mkstatic.lianbian.net/202112012325135.png" alt="重启服务"></p><h3 id="测试效果-1"><a href="#测试效果-1" class="headerlink" title="测试效果"></a>测试效果</h3><p><img src="http://mkstatic.lianbian.net/202112012325174.png" alt="开始1条记录"></p><p><img src="http://mkstatic.lianbian.net/202112012326934.png" alt="删除limit 1"></p><p><img src="http://mkstatic.lianbian.net/202112012327419.png" alt="手动编译"></p><p><img src="http://mkstatic.lianbian.net/202112012327652.png" alt="5条记录全部显示"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章写到这里就完成了，几个注意点：</p><ol><li>很多时候是因为idea自动编译没生效导致热部署失败，采用<strong>手动编译</strong>方式，也挺好的；</li><li>完整的简洁的项目代码放在了github上边（<a href="https://github.com/lianbian/JavaHotDevbugTool%EF%BC%89%EF%BC%8C%E9%9C%80%E8%A6%81%E7%9A%84%E8%87%AA%E5%8F%96%EF%BC%8C%E6%8B%BF%E7%9D%80%E5%B0%B1%E8%83%BD%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%96%87%E6%9C%AB%E7%9A%84%E6%9F%A5%E7%9C%8B%E5%8E%9F%E6%96%87%EF%BC%9B">https://github.com/lianbian/JavaHotDevbugTool），需要的自取，拿着就能跑起来的项目，也可以文末的查看原文；</a></li><li>最后，就是<strong>注意细节</strong>。</li></ol><p>衷心感谢每一位认真读文章的人，我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写Redis的LRU淘汰策略</title>
    <link href="/redis/21e0e69ffb2a.html"/>
    <url>/redis/21e0e69ffb2a.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天我们这篇文章的目的只有一个，那就是<code>搞懂LRU淘汰策略</code>以及<code>实现一个LRU算法</code>。</p><p>文章会结合图解循序渐进的讲解，跟着我的思路慢慢来就能看懂，我们开始吧。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p><img src="http://mkstatic.lianbian.net/202110291439151.png" alt="LRU"></p><h2 id="Redis的淘汰策略"><a href="#Redis的淘汰策略" class="headerlink" title="Redis的淘汰策略"></a>Redis的淘汰策略</h2><p>为什么要有淘汰策略呢？</p><p><strong>因为存储内存的空间是有限的，所以需要有淘汰的策略。</strong></p><p>Redis的清理内存淘汰策略有哪些呢？</p><p><img src="http://mkstatic.lianbian.net/202110291452127.png" alt="Redis内存淘汰策略"></p><h2 id="LRU算法简介"><a href="#LRU算法简介" class="headerlink" title="LRU算法简介"></a>LRU算法简介</h2><p>LRU是<code>Least Recently Used</code>的缩写，即<code>最近最少使用</code>，是一种常见的页面置换算法。</p><p>我们手机的后台窗口（苹果手机双击Home的效果），他总是会把最近常用的窗口放在最前边，而最不常用的应用窗口，就排列在后边了，如果再加上只能放置N个应用窗口的限制，淘汰最不常用的最近最少用的应用窗口，那就是一个活生生的<code>LRU</code>。</p><p><img src="http://mkstatic.lianbian.net/202110290847476.png" alt="手机后台应用窗口"></p><h2 id="实现思想推导"><a href="#实现思想推导" class="headerlink" title="实现思想推导"></a>实现思想推导</h2><p><img src="http://mkstatic.lianbian.net/202110290919765.png" alt="手机应用案例"></p><p>从上边的示意图，我们可以分析出这么几个点：</p><ol><li>有序；</li><li>如果应用开满3个了，要淘汰最不常用的应用，每次新访问应用，需要把数据插入队头（按照业务可以设定左右哪一边是队头）；</li><li>O(1)复杂度是我们查找数据的追求，我们什么结构能够实现快速的O(1)查找呢？</li></ol><p><img src="http://mkstatic.lianbian.net/202110291228385.png" alt="推导图"></p><p><strong>通过上边的推导，我们就能得出，<code>LRU</code>算法核心是<code>HashMap + DoubleLinkedList</code>。</strong></p><p>思想搞明白了，我们接下来编码实现。</p><h2 id="巧用LinkedHashMap"><a href="#巧用LinkedHashMap" class="headerlink" title="巧用LinkedHashMap"></a>巧用LinkedHashMap</h2><p>我们查看Java的<code>LinkedHashMap</code>使用说明。</p><p><img src="http://mkstatic.lianbian.net/202110291019095.png" alt="LinkedHashMap使用说明"></p><p><strong>翻译：这种Map结构很适合构建LRU缓存。</strong></p><p>继承<code>LinkedHashMap</code>实现<code>LRU</code>算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUDemo</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUDemo</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">super</span>(capacity, <span class="hljs-number">0.75F</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.size() &gt; capacity;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LRUDemo</span> <span class="hljs-variable">lruDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUDemo</span>(<span class="hljs-number">3</span>);<br>        lruDemo.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>        lruDemo.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        lruDemo.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>        System.out.println(lruDemo.keySet());<br><br>        lruDemo.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>        lruDemo.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;e&quot;</span>);<br>        System.out.println(lruDemo.keySet());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重点讲解：</strong></p><ol><li><p>构造方法：<code>super(capacity, 0.75F, true)</code>，主要看第三个参数：</p><ol><li><p><img src="http://mkstatic.lianbian.net/202110291025402.png" alt="order参数"></p></li><li><p><code>true -&gt; access-order // false -&gt; insertion-order</code>即按照访问时间排序，还是按照插入的时间来排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造方法改成false</span><br><span class="hljs-built_in">super</span>(capacity, <span class="hljs-number">0.75F</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">LRUDemo</span> <span class="hljs-variable">lruDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUDemo</span>(<span class="hljs-number">3</span>);<br>  lruDemo.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>);<br>  lruDemo.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>  lruDemo.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>  System.out.println(lruDemo.keySet());<br><br>  lruDemo.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;y&quot;</span>);<br>  <span class="hljs-comment">// 构造方法order=true，输出：[2,3,1]，</span><br>  <span class="hljs-comment">// 构造方法order=false，输出：[1,2,3]，</span><br>  System.out.println(lruDemo.keySet());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p><code>removeEldestEntry</code>方法：什么时候移除最年长的元素。</p></li></ol><p>通过上面，相信大家对<code>LRU</code>算法有所理解了，接下来我们不依赖JDK的<code>LinkedHashMap</code>，通过我们自己的理解，动手实现一个<code>LRU</code>算法，让我们的<code>LRU</code>算法刻入我们的大脑。</p><h2 id="手写LRU"><a href="#手写LRU" class="headerlink" title="手写LRU"></a>手写LRU</h2><p>上边的推导图中可以看出，我们用<code>HashMap</code>来做具体的数据储存，但是我们还需要构造一个<code>DoubleLinkedList</code>对象（结构体）来储存<code>HashMap</code>的具体<code>key</code>顺序关系。</p><h3 id="第一步：构建DoubleLinkedList对象"><a href="#第一步：构建DoubleLinkedList对象" class="headerlink" title="第一步：构建DoubleLinkedList对象"></a>第一步：构建DoubleLinkedList对象</h3><ol><li>所以我们现在<strong>第一步</strong>，就是构建一个<code>DoubleLinkedList</code>对象：</li></ol><p><img src="http://mkstatic.lianbian.net/202110291249801.png" alt="DoubleLinkedList示意图"></p><p>我们可以从<code>HashMap</code>源码中找一些灵感，他们都是使用一个<code>Node</code>静态内部类来储存节点的值。</p><h3 id="第二步：构建节点"><a href="#第二步：构建节点" class="headerlink" title="第二步：构建节点"></a>第二步：构建节点</h3><p>通过上边的示意图，我们可以得知<strong>节点</strong>应该要储存的内容：</p><ol><li>key</li><li>value</li><li>prev节点</li><li>next节点</li></ol><p>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; &#123;<br>    K key;<br>    V value;<br>    Node&lt;K, V&gt; prev;<br>    Node&lt;K, V&gt; next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.prev = <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.prev = <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三步：初始化DoubleLinkedList对象"><a href="#第三步：初始化DoubleLinkedList对象" class="headerlink" title="第三步：初始化DoubleLinkedList对象"></a>第三步：初始化DoubleLinkedList对象</h3><p><img src="http://mkstatic.lianbian.net/202110291312430.png" alt="DoubleLinkedList初始化示意图"></p><p>还是通过上边的示意图，我们可以得知<strong>DoubleLinkedList对象</strong>应该要储存的内容：</p><ol><li>头节点</li><li>尾节点</li></ol><p>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span>&lt;K, V&gt; &#123;<br>    Node&lt;K, V&gt; head;<br>    Node&lt;K, V&gt; tail;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DoubleLinkedList</span><span class="hljs-params">()</span>&#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;();<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从头添加节点"><a href="#从头添加节点" class="headerlink" title="从头添加节点"></a>从头添加节点</h4><p><img src="http://mkstatic.lianbian.net/202110291329584.png" alt="从头添加节点"></p><p>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addHead</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> &#123;<br>    node.next = head.next;<br>    node.prev = head;<br>    head.next.prev = node;<br>    head.next = node;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p><img src="http://mkstatic.lianbian.net/202110291341404.png" alt="删除节点"></p><p>翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> &#123;<br>    node.next.prev = node.prev;<br>    node.prev.next = node.next;<br>    node.prev = <span class="hljs-literal">null</span>;<br>    node.next = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取最后一个节点"><a href="#获取最后一个节点" class="headerlink" title="获取最后一个节点"></a>获取最后一个节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> tail.prev;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第四步：LRU对象属性"><a href="#第四步：LRU对象属性" class="headerlink" title="第四步：LRU对象属性"></a>第四步：LRU对象属性</h3><h4 id="cacheSize"><a href="#cacheSize" class="headerlink" title="cacheSize"></a>cacheSize</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cacheSize;<br></code></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Integer, Node&lt;Integer, String&gt;&gt; map;<br></code></pre></td></tr></table></figure><h4 id="doubleLinkedList"><a href="#doubleLinkedList" class="headerlink" title="doubleLinkedList"></a>doubleLinkedList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DoubleLinkedList&lt;Integer, String&gt; doubleLinkedList;<br></code></pre></td></tr></table></figure><h3 id="第五步：LRU对象的方法"><a href="#第五步：LRU对象的方法" class="headerlink" title="第五步：LRU对象的方法"></a>第五步：LRU对象的方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUDemo</span><span class="hljs-params">(<span class="hljs-type">int</span> cacheSize)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cacheSize = cacheSize;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    doubleLinkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DoubleLinkedList</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="refreshNode刷新节点"><a href="#refreshNode刷新节点" class="headerlink" title="refreshNode刷新节点"></a>refreshNode刷新节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshNode</span><span class="hljs-params">(Node node)</span> &#123;<br>    doubleLinkedList.removeNode(node);<br>    doubleLinkedList.addHead(node);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get节点"><a href="#get节点" class="headerlink" title="get节点"></a>get节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br><br>    Node&lt;Integer, String&gt; node = map.get(key);<br>    refreshNode(node);<br>    <span class="hljs-keyword">return</span> node.value;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put节点"><a href="#put节点" class="headerlink" title="put节点"></a>put节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, String value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (map.containsKey(key)) &#123;<br>        Node&lt;Integer, String&gt; node = map.get(key);<br>        node.value = value;<br>        map.put(key, node);<br><br>        refreshNode(node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (map.size() == cacheSize) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">lastNode</span> <span class="hljs-operator">=</span> doubleLinkedList.getLast();<br>            map.remove(lastNode.key);<br>            doubleLinkedList.removeNode(lastNode);<br>        &#125;<br><br>        Node&lt;Integer, String&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(key, value);<br>        map.put(key, newNode);<br>        doubleLinkedList.addHead(newNode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第六步：测试"><a href="#第六步：测试" class="headerlink" title="第六步：测试"></a>第六步：测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">LRUDemo</span> <span class="hljs-variable">lruDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUDemo</span>(<span class="hljs-number">3</span>);<br>    lruDemo.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;美团&quot;</span>);<br>    lruDemo.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;微信&quot;</span>);<br>    lruDemo.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;抖音&quot;</span>);<br>    lruDemo.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;微博&quot;</span>);<br>    System.out.println(lruDemo.map.keySet());<br><br>    System.out.println(lruDemo.get(<span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>LRU</code>算法到这里就写完啦，<a href="https://www.lianbian.net/2021/10/29/Redis/LRU%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81/">完整的代码</a>可以从阅读原文的链接地址获取。</p><p>希望看完这篇文章之后，彻底弄懂LRU算法。</p><p>衷心感谢每一位认真读文章的人，我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>参考资料：</p><p><a href="https://www.bilibili.com/video/BV1Hy4y1B78T?p=64">https://www.bilibili.com/video/BV1Hy4y1B78T?p=64</a></p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章。</p><p><img src="https://mkstatic.lianbian.net/202203160758473.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几行代码，优雅的实现策略模式</title>
    <link href="/java/5f304de4d3ee.html"/>
    <url>/java/5f304de4d3ee.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是<code>连边</code>，这是我的第<code>46</code>篇原创文章。</p><p>这一篇文章不长，主要就是通过几行代码来实现一个我们常说的<code>策略模式</code>。</p><h2 id="什么策略模式"><a href="#什么策略模式" class="headerlink" title="什么策略模式"></a>什么策略模式</h2><p>比如我们需要实现一个两个数的加、减、乘、除的计算器。</p><p>一般的写法会这样子写：</p><p><img src="https://mkstatic.lianbian.net/202211132218136.png" alt="计算器实现方法ifelse版本"></p><p>或者</p><p><img src="https://mkstatic.lianbian.net/202211132220983.png" alt="计算器实现方法switch版本"></p><p>上边都是很<code>直男</code>的解决方式，为了后期方便扩展，而又对原来的代码无侵入性，其实可以使用<code>策略模式</code>，<code>根据我们的运算符号来对两个数字作不同的运算</code>这是我们抽象出来的需求。</p><p>基于我们Spring注解，可以很简单的实现我们的策略模式（这一点被同事笑话了，包括我之前的文章里面，都用到了代理模式来实现策略模式，后来发现是交了代码智商税。）</p><h2 id="基于Spring注解的解决方案"><a href="#基于Spring注解的解决方案" class="headerlink" title="基于Spring注解的解决方案"></a>基于Spring注解的解决方案</h2><p>创建计算器接口类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ICalc</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算器的运算方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> i</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> j</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>分别创建加减乘除运算类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service(&quot;add&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalc</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICalc</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i+j;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service(&quot;sub&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalc</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICalc</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i-j;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service(&quot;mult&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultCalc</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICalc</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i*j;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service(&quot;div&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DivCalc</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ICalc</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">operation</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-keyword">return</span> i/j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>依赖注入使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>Map&lt;String, ICalc&gt; calcMap;<br></code></pre></td></tr></table></figure><p>调用控制器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用的URL：</span><br><span class="hljs-comment"> * http://127.0.0.1:8001/user/calc/add 加法调用</span><br><span class="hljs-comment"> * http://127.0.0.1:8001/user/calc/sub 减法调用</span><br><span class="hljs-comment"> * http://127.0.0.1:8001/user/calc/mult 乘法调用</span><br><span class="hljs-comment"> * http://127.0.0.1:8001/user/calc/div 除法调用</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> opStr 运算符</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(path = &quot;/calc/&#123;opStr&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">op</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String opStr)</span> &#123;<br>  <span class="hljs-type">ICalc</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> calcMap.getOrDefault(opStr, <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == calc) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;没有找到正确的策略&quot;</span>;<br>  &#125;<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> calc.operation(i, j) + <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整的代码：<a href="https://github.com/lianbian/EhCache">https://github.com/lianbian/EhCache</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>依赖Spring的依赖注入实现优雅的策略模式，告别各种<code>if else</code>、<code>switch</code>、<code>以及代理或者自定义注解实现策略模式</code>。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搞懂Redis的跳跃表结构</title>
    <link href="/redis/c8b89b4766ce.html"/>
    <url>/redis/c8b89b4766ce.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天更新一篇关于Redis跳表结构相关的文章，希望你能够彻底弄懂Redis跳表结构。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>跳跃表是<code>zset</code>（有序集合）的基础数据结构。跳跃表可以高效的保持元素有序，并且实现相对简单、直观的平衡树。</p><h2 id="B站视频"><a href="#B站视频" class="headerlink" title="B站视频"></a>B站视频</h2><p>友情提示，可以快速跳过抛硬币环节，有群友统计了，抛了<code>22</code>次硬币。</p><p><a href="https://www.bilibili.com/video/BV1tK4y1X7de?from=search&seid=1013717057">Redis Skip List B站视频</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>看过视频之后，对跳跃表结构怎么进行增删改查的相信大家有了很直观的理解。</p><p>其实跳跃表是受<code>多层链表</code>的想法启发设计得来的。</p><p>如果上一层的链表的节点个数，是下面一层的节点个数的一半，这样查找就非常类似于一个<code>二分查找</code>。</p><p>但是为什么不直接用二分查找的方式去解决问题， 还要用随机的方式（抛硬币）来解决层数的问题呢？</p><p>试想一下，如果我们结构上强制着二分查找，相邻的两层链表上的节点个数严格按照2：1的对应关系，<strong>那么在插入新节点的时候，就会打乱这层对应关系，要维护这层关系，又必须把心插入的节点后边的所有节点重新进行调整，这又让时间复杂度退化为O(N)，删除数据也有同样的问题。</strong></p><p>跳跃表为了避免这一问题，就采用了随机层数的方式来巧妙的解决。</p><p><strong>不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数（level），新插入的节点就会根据自己的层数决定该节点是否在这层的链表上</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天这篇文章很短，主要的内容就是在那个强烈推荐的视频。</p><p>如果想更深入的了解，也推荐另外一篇文章<a href="https://juejin.cn/post/6901139528422178824">Redis 数据结构之跳跃表（skiplist）</a>。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章。</p><p><img src="https://mkstatic.lianbian.net/202203160802606.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Maven同一依赖多版本共存</title>
    <link href="/java/d081ac447099.html"/>
    <url>/java/d081ac447099.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题现状"><a href="#问题现状" class="headerlink" title="问题现状"></a>问题现状</h2><p>由于是一个迭代比较久的项目，项目中已经存在poi-tl 1.5.x的依赖，poi-tl v1.5.x是构建在Apache poi3.16上的版本，而我们现在要使用到easyexcel来处理导出，而easyexcel最低的Apache poi版本要求是4.1.2，将项目中已有poi的3.16升级到4.12时，旧代码出错，但是不升级就无法使用easyexcel。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>解决问题思路无非就是两种：</p><ol><li><p>将项目中已有的poi3.16升级到4.12，解决升级后代码出错的地方；</p><p>优点：jar包依赖清晰，在代码改动量可控的情况下，推荐使用该方式；</p><p>缺点：代码改动量大，工作量大，而且容易对之前的功能带来不稳定因素；</p></li><li><p>使用maven-shade-plugin插件来解决，让项目依赖多个版本的poi版本；</p><p>优点：对原来的功能无影响，代码改动量小；</p><p>缺点：jar依赖变大，因为依赖了同一个依赖的2个版本；jar包依赖不那么清晰优雅；</p></li></ol><p>今天文章主角就是第2种方式。</p><p><strong>它的核心思路就是把easyexcel中的高版本poi包改个名字，同时easyexcel中引用的地方也改名（自动），并且代码中用高本版的地方也改个名（手动）。</strong></p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><ol><li><p>创建一个空maven项目，项目名称为jarjar，引入easyexcel的依赖；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查看其依赖的poi版本</p><p><img src="https://mkstatic.lianbian.net/202208160749041.png" alt="easyexcel poi版本"></p></li><li><p>引入插件并且配置好修改的方式；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">createDependencyReducedPom</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">createDependencyReducedPom</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">relocations</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">relocation</span>&gt;</span><br>                                <span class="hljs-comment">&lt;!-- &lt;build&gt;</span><br><span class="hljs-comment">        &lt;plugins&gt;</span><br><span class="hljs-comment">            &lt;plugin&gt;</span><br><span class="hljs-comment">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="hljs-comment">                &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="hljs-comment">                &lt;version&gt;3.2.4&lt;/version&gt;</span><br><span class="hljs-comment">                &lt;executions&gt;</span><br><span class="hljs-comment">                    &lt;execution&gt;</span><br><span class="hljs-comment">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="hljs-comment">                        &lt;goals&gt;</span><br><span class="hljs-comment">                            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="hljs-comment">                        &lt;/goals&gt;</span><br><span class="hljs-comment">                        &lt;configuration&gt;</span><br><span class="hljs-comment">                            &lt;createDependencyReducedPom&gt;true&lt;/createDependencyReducedPom&gt;</span><br><span class="hljs-comment">                            &lt;relocations&gt;</span><br><span class="hljs-comment">                                &lt;relocation&gt;</span><br><span class="hljs-comment">                                    &lt;!-- 改名前 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>                                    <span class="hljs-comment">&lt;!-- 改名后 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">shadedPattern</span>&gt;</span>shaded.org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">shadedPattern</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">relocation</span>&gt;</span><br><br>                                <span class="hljs-comment">&lt;!-- 可以配置多个 --&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">relocation</span>&gt;</span><br>                                    <span class="hljs-comment">&lt;!-- 改名前 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>com.deepoove.poi.XWPFTemplate<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>                                    <span class="hljs-comment">&lt;!-- 改名后 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">shadedPattern</span>&gt;</span>shaded.com.deepoove.poi.XWPFTemplate<span class="hljs-tag">&lt;/<span class="hljs-name">shadedPattern</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">relocation</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">relocations</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>改名前 --&gt;<br>                                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>                                <span class="hljs-comment">&lt;!-- 改名后 --&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">shadedPattern</span>&gt;</span>shaded.org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">shadedPattern</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">relocation</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">relocations</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>较为完整的pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jarjar<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easyexcel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">createDependencyReducedPom</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">createDependencyReducedPom</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">relocations</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">relocation</span>&gt;</span><br>                                    <span class="hljs-comment">&lt;!-- 改名前 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>                                    <span class="hljs-comment">&lt;!-- 改名后 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">shadedPattern</span>&gt;</span>shaded.org.apache.poi<span class="hljs-tag">&lt;/<span class="hljs-name">shadedPattern</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">relocation</span>&gt;</span><br><br>                                <span class="hljs-comment">&lt;!-- 可以配置多个 --&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">relocation</span>&gt;</span><br>                                    <span class="hljs-comment">&lt;!-- 改名前 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>com.deepoove.poi.XWPFTemplate<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>                                    <span class="hljs-comment">&lt;!-- 改名后 --&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">shadedPattern</span>&gt;</span>shaded.com.deepoove.poi.XWPFTemplate<span class="hljs-tag">&lt;/<span class="hljs-name">shadedPattern</span>&gt;</span><br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">relocation</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">relocations</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>打出jar包；</p><p>执行<code>mvn package</code>，如果是IDEA直接双击Lifecycle中的<code>package</code>就行了。</p><p><img src="https://mkstatic.lianbian.net/202208160738987.png" alt="打出jar包"></p><p>这时target目录中会有两个包，一个是original开头的原本包，因为我们没有新建类，所以这个包是空的。<br>另一个是和<code>artifactId-version.jar</code>的包，<code>artifactId</code>和<code>version</code>是本项目创建时填写的坐标。</p><p>如图，我的这个maven项目叫jarjar，版本是1.0：</p><p><img src="https://mkstatic.lianbian.net/202208160751564.png" alt="找到指定的jar包"></p></li><li><p>依赖本地jar，运行项目；</p><ol><li><p>自定义目录，这里在project的根目录新建lib文件夹，将jar放进去</p></li><li><p>引入jar包</p><p><img src="https://mkstatic.lianbian.net/202208160759463.png" alt="jarjar项目的pom信息"></p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jarjar<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/src/main/java/lib/jarjar-1.0-SNAPSHOT.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>处理打包</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>lib<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/BOOT-INF/lib/<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>至此，已经无损的引入了easyexcel依赖，easyexcel中引用的地方也改名（自动），并且代码中用高本版的地方也改个名（手动）。</strong></p><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p>插件官网：<a href="https://maven.apache.org/plugins/maven-shade-plugin/index.html">https://maven.apache.org/plugins/maven-shade-plugin/index.html</a></p><p>maven-shade-plugin解决Maven同一依赖多版本共存：<a href="https://www.cnblogs.com/lixin-link/p/15507326.html">https://www.cnblogs.com/lixin-link/p/15507326.html</a></p><p>maven引入本地jar包的方法：<a href="https://cloud.tencent.com/developer/article/1510883">https://cloud.tencent.com/developer/article/1510883</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的undo日志</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/2b6e298ebb90.html"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/2b6e298ebb90.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天这篇文章给大家带来MySQL中另外一个重要的日志 - <code>undo log</code>。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p><img src="http://mkstatic.lianbian.net/202110141040653.png" alt="undo log文章导读"></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>undo log</code>是innodb引擎的一种日志，在事务的修改记录之前，会把该记录的原值（before image）先保存起来（undo log）再做修改，以便修改过程中出错能够<strong>恢复原值</strong>或者其他的事务<strong>读取</strong>。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>从概念的定义不难看出<code>undo log</code>的两个作用：</p><ol><li><strong>事务回滚 - 原子性：</strong> undo log是为了实现事务的原子性而出现的产物，事务处理的过程中，如果出现了错误或者用户执行<code>ROLLBACK</code>语句，MySQL可以利用undo log中的备份将数据恢复到事务开始之前的状态。</li><li><strong>多个行版本控制（MVCC）- 隔离性：</strong> undo log在MySQL InnoDB储存引擎中用来实现多版本并发控制，事务未提交之前，当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。</li></ol><h2 id="什么时候会生成undo-log"><a href="#什么时候会生成undo-log" class="headerlink" title="什么时候会生成undo log"></a>什么时候会生成undo log</h2><p>在事务中，进行以下四种操作，都会创建<code>undo log</code>：</p><ol><li><code>insert</code>用户定义的表</li><li><code>update</code>或者<code>delete</code>用户定义的表</li><li><code>insert</code>用户定义的临时表</li><li><code>update</code>或者<code>delete</code>用户定义的临时表</li></ol><h2 id="存放在哪里？"><a href="#存放在哪里？" class="headerlink" title="存放在哪里？"></a>存放在哪里？</h2><p>既然是一种日志，<strong>储存在什么目录？</strong> 又是<strong>怎样储存的？</strong></p><h3 id="储存在什么目录？"><a href="#储存在什么目录？" class="headerlink" title="储存在什么目录？"></a>储存在什么目录？</h3><p>这里要需要说明一下，在<code>MySQL5.6.3</code>之前的版本中，这个<code>undo tablespace</code>是和<code>system tablespace</code>系统表空间存放在一起的，也就是没有单独的<code>undo log</code>文件，直接存放在<code>ibdata1</code>文件里边，在<code>MySQL5.6.3</code>之后的版本中，MySQL支持将undo log tablespace单独剥离出来，但这个特性依然很鸡肋：</p><ol><li>要在安装数据库的时候，就指定好独立undo tablespace，在安装完成后不可更改；</li><li>undo tablespace的space id必须从1开始，无法增加或者删除undo tablespace；</li></ol><p>特意安装了<code>MySQL5.6.39</code>验证一波：</p><p><img src="http://mkstatic.lianbian.net/202110131612277.png" alt="undo tablespace表空间设置"></p><p>到了<code>MySQL5.7</code>版本，终于引入期待已久的功能：即在线truncate undo tablespace（解决了第一个鸡肋点，可以在安装数据库之后更改undo tablespace）</p><p>在<code>MySQL8.0</code>中，InnoDB再进一步，对undo log做了进一步的改进：</p><ol><li><strong>从8.0.3版本开始，默认undo tablespace的个数从0调整为2</strong>，也就是在8.0版本中，独立undo tablespace被默认打开。修改该参数为0会报warning并在未来不再支持；</li><li>无需从space_id 1开始创建undo tablespace，这样解决了In-place upgrade或者物理恢复到一个打开了Undo tablespace的实例所产生的space id冲突。不过依然要求undo tablespace的space id是连续分配的；</li></ol><p>根据官方的MySQL结构图，我画了MySQL的结构简图，描述了undo log在数据库磁盘中的位置，只需要关注简图中画<strong>红色方框</strong>和<strong>绿色方框</strong>的模块。</p><p><img src="http://mkstatic.lianbian.net/202110121327568.png" alt="MySQL的结构简图"></p><p>我们会发现，随着MySQL版本的迭代，已经把undo log单独剥离出来了，那我们思考一下：<strong>为什么要支持把undolog的tablespace单独剥离出来呢？</strong></p><p>这是从性能的角度来考量的。原先的undolog和系统表空间共享一个表空间，这样在记录undolog的时候，和其他的一些使用系统表空间来存储的操作肯定会存在磁盘I/O的竞争。但是如果我们把undolog的表空间单独拉出来，支持让其自定义目录和表空间的数量，这样我们可以把undolog配置单独的磁盘目录，提高undo log日志的读写性能，也能方便DBA操作。</p><p>阅读到这里，我们弄清楚了undo log是储存在单独的undo tablespace，接下来我们继续研究undo tablespace是以什么样的结构储存日志内容的。</p><h3 id="undo-tablespace-表空间"><a href="#undo-tablespace-表空间" class="headerlink" title="undo tablespace - 表空间"></a>undo tablespace - 表空间</h3><p>在MySQL中，undo tablespace定义了回滚段 rollback segments 用来存放undo log。</p><p>我们这里来看一下undo tablespace的结构体源码。</p><p>（ps：我们还是要养成看源码的习惯，我们搜索到的知识观点很多，如何甄别观点的对与错，只有从源码层面找到答案，当然这里看MySQL源码只是为了进一步说明undo tablespace表空间定义了多个rollback segments - rseg）</p><p>我的源码版本是<code>8.0.13</code>，可以给订阅号「连边」发送指令<code>mysql8013</code>获取源码包，也可以自己在github上找对应的版本。</p><p><strong>unbo tablespace表空间结构体源码路径</strong></p><p><code>mysql-server-mysql-8.0.13/storage/innobase/include/trx0purge.h</code></p><p><strong>undo tablespace结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** An undo::Tablespace object is used to easily convert between</span><br><span class="hljs-comment">undo_space_id and undo_space_num and to create the automatic file_name</span><br><span class="hljs-comment">and space name.  In addition, it is used in undo::Tablespaces to track</span><br><span class="hljs-comment">the trx_rseg_t objects in an Rsegs vector. So we do not allocate the</span><br><span class="hljs-comment">Rsegs vector for each object, only when requested by the constructor. */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tablespace</span> &#123;<br> <span class="hljs-comment">/** ... **/</span><br> <span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">/** Undo Tablespace ID. */</span><br>  <span class="hljs-type">space_id_t</span> m_id;<br><br>  <span class="hljs-comment">/** Undo Tablespace number, from 1 to 127. This is the</span><br><span class="hljs-comment">  7-bit number that is used in a rollback pointer.</span><br><span class="hljs-comment">  Use id2num() to get this number from a space_id. */</span><br>  <span class="hljs-type">space_id_t</span> m_num;<br><br>  <span class="hljs-comment">/** The tablespace name, auto-generated when needed from</span><br><span class="hljs-comment">  the space number. */</span><br>  <span class="hljs-type">char</span> *m_space_name;<br><br>  <span class="hljs-comment">/** The tablespace file name, auto-generated when needed</span><br><span class="hljs-comment">  from the space number. */</span><br>  <span class="hljs-type">char</span> *m_file_name;<br><br>  <span class="hljs-comment">/** The tablespace log file name, auto-generated when needed</span><br><span class="hljs-comment">  from the space number. */</span><br>  <span class="hljs-type">char</span> *m_log_file_name;<br><br>  <span class="hljs-comment">/** List of rollback segments within this tablespace.</span><br><span class="hljs-comment">  This is not always used. Must call init_rsegs to use it. */</span><br>  Rsegs *m_rsegs;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上边的源码可知，在我们的undo tablespace表空间结构体定义里边，有<code>Rsegs</code>的定义，这个就是我们前边说的<code>回滚段（Rollback Segments）</code>，我们继续从源码来研究<code>回滚段（Rollback Segments）</code>结构体。</p><h3 id="resg-回滚段"><a href="#resg-回滚段" class="headerlink" title="resg - 回滚段"></a>resg - 回滚段</h3><p><strong>回滚段结构体源码路径</strong></p><p><code>mysql-server-mysql-8.0.13/storage/innobase/include/trx0types.h</code></p><p><strong>回滚段rseg结构体源码</strong></p><p>undo log tablespace结构体中<code>Rsegs</code>是<code>trx_rseg_t</code>的<code>std::vector</code>封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** The rollback segment memory object */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">trx_rseg_t</span> &#123;<br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-comment">/** rollback segment id == the index of its slot in the trx</span><br><span class="hljs-comment">  system file copy */</span><br>  ulint id;<br><br>  <span class="hljs-comment">/** mutex protecting the fields in this struct except id,space,page_no</span><br><span class="hljs-comment">  which are constant */</span><br>  RsegMutex mutex;<br><br>  <span class="hljs-comment">/** space ID where the rollback segment header is placed */</span><br>  <span class="hljs-type">space_id_t</span> space_id;<br><br>  <span class="hljs-comment">/** page number of the rollback segment header */</span><br>  <span class="hljs-type">page_no_t</span> page_no;<br><br>  <span class="hljs-comment">/** page size of the relevant tablespace */</span><br>  <span class="hljs-type">page_size_t</span> page_size;<br><br>  <span class="hljs-comment">/** maximum allowed size in pages */</span><br>  ulint max_size;<br><br>  <span class="hljs-comment">/** current size in pages */</span><br>  ulint curr_size;<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-comment">/* Fields for update undo logs */</span><br>  <span class="hljs-comment">/** List of update undo logs */</span><br>  <span class="hljs-built_in">UT_LIST_BASE_NODE_T</span>(<span class="hljs-type">trx_undo_t</span>) update_undo_list;<br><br>  <span class="hljs-comment">/** List of update undo log segments cached for fast reuse */</span><br>  <span class="hljs-built_in">UT_LIST_BASE_NODE_T</span>(<span class="hljs-type">trx_undo_t</span>) update_undo_cached;<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br>  <span class="hljs-comment">/* Fields for insert undo logs */</span><br>  <span class="hljs-comment">/** List of insert undo logs */</span><br>  <span class="hljs-built_in">UT_LIST_BASE_NODE_T</span>(<span class="hljs-type">trx_undo_t</span>) insert_undo_list;<br><br>  <span class="hljs-comment">/** List of insert undo log segments cached for fast reuse */</span><br>  <span class="hljs-built_in">UT_LIST_BASE_NODE_T</span>(<span class="hljs-type">trx_undo_t</span>) insert_undo_cached;<br><br>  <span class="hljs-comment">/*--------------------------------------------------------*/</span><br><br>  <span class="hljs-comment">/** Page number of the last not yet purged log header in the history</span><br><span class="hljs-comment">  list; FIL_NULL if all list purged */</span><br>  <span class="hljs-type">page_no_t</span> last_page_no;<br><br>  <span class="hljs-comment">/** Byte offset of the last not yet purged log header */</span><br>  ulint last_offset;<br><br>  <span class="hljs-comment">/** Transaction number of the last not yet purged log */</span><br>  <span class="hljs-type">trx_id_t</span> last_trx_no;<br><br>  <span class="hljs-comment">/** TRUE if the last not yet purged log needs purging */</span><br>  ibool last_del_marks;<br><br>  <span class="hljs-comment">/** Reference counter to track rseg allocated transactions. */</span><br>  std::atomic&lt;ulint&gt; trx_ref_count;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个回滚段维护了一个<code>Rollback Segment Header Page</code>，限于篇幅，这里不再深入研究，因为他不影响我们继续阅读，如果感兴趣的读者，可以看我最后贴出来的链接深入了解。</p><h3 id="undo-tablespace-储存结构示意图"><a href="#undo-tablespace-储存结构示意图" class="headerlink" title="undo tablespace 储存结构示意图"></a>undo tablespace 储存结构示意图</h3><p>为了巩固前边说的内容，这里我画了一张undo tablespace表空间结构图，希望能帮您巩固。</p><p><img src="http://mkstatic.lianbian.net/202110140914268.png" alt="undo tablespace表空间结构图"></p><h3 id="undo-log的类型"><a href="#undo-log的类型" class="headerlink" title="undo log的类型"></a>undo log的类型</h3><p>为了更好的处理回滚，undo log和之前说的redo log记录物理日志不一样，它是逻辑日志，<strong>可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</strong> 对应着undo log的两种类型，分别是 <code>insert undo log</code>和<code>update undo log</code>。</p><p><strong>insert undo log长啥样</strong></p><p>对于 insert 类型的sql，会在undo log中记录下方才你insert 进来的数据的ID，根据ID完成精准的删除。</p><p>insert 类型的undo log长下面这样：</p><p><img src="http://mkstatic.lianbian.net/202110141001577.png" alt="insert undo log-不是我画的"></p><p>可能你打眼一看上图就能知道各部分都有啥用。<br>但是，不知道你会不会纳闷这样一个问题：不是说对于insert 类型的undo log MySQL记录的是方才插入行ID吗？怎么上图整出来的了这么多Col1、Col2、Col2。<br>其实是MySQL设计的很周到，因为它是针对联合主键设计的。</p><p><strong>update undo log长啥样</strong></p><p>一条update sql对应undolog长如下这样：</p><p><img src="http://mkstatic.lianbian.net/202110141002721.png" alt="update undo log-不是我画的"></p><p>通过上边的基础铺垫，来到我们的实战分析环节。</p><h2 id="场景实战"><a href="#场景实战" class="headerlink" title="场景实战"></a>场景实战</h2><h3 id="事务怎么回滚的？"><a href="#事务怎么回滚的？" class="headerlink" title="事务怎么回滚的？"></a>事务怎么回滚的？</h3><p>举一个举例的案例来说明该过程。</p><p><strong>insert类型的undo log</strong></p><p>对于insert类型的sql，会在undo log中记录下insert 进来的数据的ID，当你想roll back时，根据ID完成精准的删除。<br>对于delete类型的sql，会在undo log中记录方才你删除的数据，当你回滚时会将删除前的数据insert 进去。<br>对于update类型的sql，会在undo log中记录下修改前的数据，回滚时只需要反向update即可。<br>对于select类型的sql，别费心了，select不需要回滚。<br>先看一个简单的insert undo log 链条</p><p><img src="http://mkstatic.lianbian.net/202110141025637.png" alt="insert undo log链条-不是我画的"></p><p>有一个注意点：因为单纯的insert sql不涉及多MVCC的能力。<br>所以一旦事务commit，这条insert undo log就可以直接删除了。</p><p><strong>update类型的undo log</strong></p><p>为了方便画图，重点突出链条的概念我省略了update undo log的部分内容<br>一个事物A开启后插图了一条记录：name = tom，MySQL会记录下这样一条undo log</p><p><img src="http://mkstatic.lianbian.net/202110141049207.png" alt="undo log记录-不是我画的"></p><p>随后先后来了两个事物：<br>事物B，事物ID=61，它执行sql将name 改成jerry。<br>事物C，事物ID=62，它执行sql将name 改成tom。<br>于是MySQL记录下这样一条新的undo log</p><p><img src="http://mkstatic.lianbian.net/202110141031889.png" alt="事务执行逻辑-不是我画的"></p><p>你可以看到，MySQL会将对一行数据的修改undo log通过DATA_ROLL_ID指针连接在一起形成一个undo log链表链条。这样事物C如果想回滚，他会将数据回滚到事物B修改后的状态。而事物B想回滚他会将数据回滚到事物A的状态。</p><h3 id="浅谈MVCC工作原理"><a href="#浅谈MVCC工作原理" class="headerlink" title="浅谈MVCC工作原理"></a>浅谈MVCC工作原理</h3><p><strong>undo log在事务开启之前就产生，当事务提交的时候，不会删除undo log，因为可能需要rollback操作，要执行回滚（rollback）操作时，从缓存中读取数据。InnoDB会将事务对应的日志保存在删除list中，后台通过purge线程进行回收处理。</strong></p><p>还是以一条sql执行update、select过程来浅析MVCC的工作原理：</p><p>执行update操作，事务A提交时候（事务还没提交），会将数据进行备份，备份到对应的undo buffer，undo log保存了未提交之前的操作日志，User表数据肯定就是持久保存到InnoDB的数据文件IBD，默认情况。</p><p>这时事务B进行查询操作，是直接读undo buffer缓存的，这时事务A还没提交事务，要回滚（rollback），是不读磁盘的，先直接从undo buffer缓存读取。</p><p><img src="http://mkstatic.lianbian.net/202110141032350.png" alt="浅析MVCC工作原理-不是我画的"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章到这里就写完了，从<code>undo log</code>概念出发，依次介绍了生成undo log、存放在哪里并且以什么方式储存的，最后结合场景实战分析了<code>undo log</code>的变化过程。</p><p>文章中使用的源码是<code>MySQL8.0.13</code>，如果有兴趣的，可以直接关注「连边」订阅号，回复<code>mysql8013</code>获取源码包。Java同学的快捷查看方式：解压源码，使用<code>IntelliJ IDEA</code>编辑器，然后根据文中的文件路径查看代码即可。</p><p>如果对文章有什么疑问或者觉得哪里不对的地方，欢迎留言或者直接加我微信跟我沟通。</p><p>衷心感谢每一位认真读文章的人，我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p><img src="http://mkstatic.lianbian.net/202110141058630.png" alt="连边的个人微信号"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>InnoDB的事务分析-Undo-Log -  <a href="https://www.leviathan.vip/2019/02/14/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-Undo-Log/">https://www.leviathan.vip/2019/02/14/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-Undo-Log/</a></p><p>MySQL · 引擎特性 · InnoDB undo log 漫游 - <a href="http://mysql.taobao.org/monthly/2015/04/01/">http://mysql.taobao.org/monthly/2015/04/01/</a></p><p>简介undo log、truncate、以及undo log如何帮你回滚事物 - <a href="https://juejin.cn/post/6900796508342321166">https://juejin.cn/post/6900796508342321166</a></p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203182132192.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怎样带动一支士气低落的队伍</title>
    <link href="/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/602d1399f916.html"/>
    <url>/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/602d1399f916.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p>做技术还是做管理，是程序员这个职业的两个发展方向，但是我认为，这两个方向是不冲突的。做为程序员，懂管理能有效的向上管理，在我的职业生涯中，第一次做管理是从半路上接手一个团队（项目），这应该也是大多数程序员的实际过程，一般是由于上一任领导的升迁或者离职，职位空缺出来后从内部提升管理者。</p><p>整篇文章是以一个<strong>中层管理人员</strong>的角色进行，希望这篇文章能给读者带来帮助。</p><p><img src="http://mkstatic.lianbian.net/202110051133670.png" alt="项目中兴"></p><h2 id="分析团队"><a href="#分析团队" class="headerlink" title="分析团队"></a>分析团队</h2><p>在公司技术团队“低迷”的时候接管的团队，举个实际事例来解析低迷，其他部门可以随便甩锅给技术部门，最后不管是不是技术问题，最后技术团队总会把锅“勇敢”的背下来，也不多做争辩，但也不过多的去解决实际生产问题，总存在一种“这个问题技术真的不能解决的”的状态。</p><p>整个团队就没有活力，来了锅就背一背，来了问题就听一听，来了任务做一做，不做过多的沟通，不关心结果。</p><p>最后整个团队的士气与战斗力可想而已。</p><h2 id="培养士气"><a href="#培养士气" class="headerlink" title="培养士气"></a>培养士气</h2><p>不管是团队还是个人，低迷的状态下，战斗力是无从说起的。所以我要着手解决的第一个问题就是，<strong>怎么去提升团队士气</strong>这个问题。</p><p>低迷不是一下就低迷下去的，而是慢慢养成的，要培养士气也不是一朝一夕的。</p><p>我从两方面来解决这个问题：</p><h3 id="重视小事情"><a href="#重视小事情" class="headerlink" title="重视小事情"></a>重视小事情</h3><p>从小的事情里边积累成就感和士气。</p><p>这里的小事情，具体就是客服部门给技术部门提出的BUG和产品优化。要端正态度，对BUG不能不管不问，一定要找到原因，是技术的原因，还是产品设计的原因，能立即解决的，就立即解决；</p><p>同时安排技术轮岗值班，做法也很简单，注册一个专门的值班QQ号，然后每天技术值班人员登录那个账号进行值班，客服人员有技术方面的问题，可以直接对接技术值班，然后由技术值班人员转交到团队内部来解决问题，给出答复。其实这种做法，挺程序员的，设计直接、简单、高效。</p><p>通过执行一段时间，慢慢的也会感受到客服部门同事对技术部门的改观，问题也能慢慢的解决，内部人员的业务能力也慢慢的提升。</p><p><strong>战斗力和士气是在小事情里边积累起来的。</strong></p><h3 id="知耻而后勇"><a href="#知耻而后勇" class="headerlink" title="知耻而后勇"></a>知耻而后勇</h3><p>对一个技术人员来说，技术不能解决问题，让别的团队任意甩锅又不能硬气的顶回去，是很憋屈（耻）的一件事情。是技术上的问题，就大胆的承认，以最积极的行动和态度来解决问题，而不是那种不了了之的状态，想必大家都想呆在<strong>有底气又硬气的团队</strong>（这里请和怼人理智的区分开来）。</p><p><strong>软绵绵的团队谁都不想呆，想呆硬气的团队。</strong></p><h2 id="利益得失"><a href="#利益得失" class="headerlink" title="利益得失"></a>利益得失</h2><p>利益，做为管理者，一定不要避讳这个词。</p><p>因为只有领导拿到好的结果，团队成员拿到好的报酬，才是你这个中层管理者最应该做的事情，也是衡量中层管理者的管理水平的标准。</p><p>利益这个词可以很广，这里我不直接讲解什么是利益，因为直接讲解什么是利益也没有太多的意思，反而感觉很功利化，我从三层（领导、中层、员工）的角色想法来分析。</p><h3 id="领导想什么"><a href="#领导想什么" class="headerlink" title="领导想什么"></a>领导想什么</h3><p>领导想做一个商城，你的第一概念是什么？淘宝？京东？</p><p>你的概念不重要，因为领导有领导层次的出发点，这个时候，你就一定要把握准<strong>领导需要一个什么样子的结果。</strong>然后再去具体的事情，具体沟通，比如：工期、功能、福利 …</p><p><strong>领导利益：拿到一个好的结果（产品）。</strong></p><h3 id="要你做什么"><a href="#要你做什么" class="headerlink" title="要你做什么"></a>要你做什么</h3><p>当领导提出做一个商城的需求的时候，要继续和他沟通。</p><ol><li>具体是要做成什么样子，做这个商城的目的是做什么？</li><li><strong>什么时候要上线？</strong></li><li>理性分析当前团队的情况，<strong>切记不能瞎承诺</strong>；</li><li><strong>做成MVP版本（最小运行版本，一般拿着去试探市场）行不行？</strong></li><li><strong>和团队商量之后，给出时间安排</strong>；</li><li>记得维持平衡，<strong>领导与中层与团队成员的平衡</strong>；</li><li>项目奖金的协商</li><li>…</li></ol><p><strong>中层利益：把握当前的团队到底能做成什么样子的结果（产品），不要让项目后期陷入被动。</strong></p><h3 id="员工想什么"><a href="#员工想什么" class="headerlink" title="员工想什么"></a>员工想什么</h3><p>员工想的什么？<strong>事少钱多离家近。</strong></p><p>就是这几个字，其中最重要的两个字就是<strong>事、钱</strong>。</p><p>做的事情，对于喜欢挑战的同事，能不能带来成长，能不能对以后有帮助；</p><p>工资待遇，值不值得员工心流的付出。</p><p><strong>尽自己的最大能力，给予和你一起并肩作战的兄弟们争取最好的利益（工资、假期、好的项目）</strong></p><p><strong>员工利益：有认同感的付出，不委屈的付出。</strong></p><p>围绕以上三个角色的利益，中层管理者慢慢去消化，最后权衡把“利益”最大化。</p><h2 id="团队目标"><a href="#团队目标" class="headerlink" title="团队目标"></a>团队目标</h2><p>前边是讲我们慢慢的怎么样把一个低迷的团队慢慢的培养起来，接下来我们就是有一支团队准备好了，你作为中层管理人员，怎么样去指挥这个团队来做好我们的项目。</p><h3 id="目标阶段化"><a href="#目标阶段化" class="headerlink" title="目标阶段化"></a>目标阶段化</h3><p>大到一个项目，小到一个需求，如果真是时间紧，任务重的情况，可以使用<strong>目标阶段化</strong>的方式，一个项目分成N个阶段，先把最核心，最紧急的需求与功能、放在第一个阶段里边来完成，因为<strong>精力是有限的</strong>，分段之后，阶段内可以专注于本阶段的目标。</p><h3 id="必须让领导知道团队目标与任务"><a href="#必须让领导知道团队目标与任务" class="headerlink" title="必须让领导知道团队目标与任务"></a>必须让领导知道团队目标与任务</h3><p>不知道大家有没有呆过这种团队，加班、各种忙碌得起飞，但是上边的领导一直团队不满意。</p><p>两个原因：</p><ol><li>短期的话，就是团队的产出不是他想要的；</li><li>长期的话，就是不知道团队在忙啥；</li></ol><p>怎么样让领导知道团队目标与阶段任务，我的建议是 <strong>最终会议领导要到</strong> 并 <strong>邮件说清楚团队现阶段目标</strong>。</p><h3 id="团队成员必须知道自己的目标与任务"><a href="#团队成员必须知道自己的目标与任务" class="headerlink" title="团队成员必须知道自己的目标与任务"></a>团队成员必须知道自己的目标与任务</h3><p>今天要做什么？要完成什么功能？</p><p>那么，明天呢？</p><p>团队成员这点必须要知道这一点，不然整天都是浑浑噩噩的，可以找合适的项目管理软件来协助，我们那时候使用的禅道。然后，在开部门会议的时候，反复强调，如果部门人员少，中层管理应该知道团队成员该阶段是在忙什么。</p><p><strong>有目标才能前进，不管是领导，还是团队成员都要有清晰目标。</strong></p><h2 id="知人善用"><a href="#知人善用" class="headerlink" title="知人善用"></a>知人善用</h2><h3 id="分析团队成员特长"><a href="#分析团队成员特长" class="headerlink" title="分析团队成员特长"></a>分析团队成员特长</h3><p>团队的每个成员都有其特色、特长，有的胆子大，有的心细，有的擅长写SQL，有的擅长利用中间件。</p><p>在项目紧急的时候，一定要找到团队成员熟悉做什么，擅长做什么，这样才能有效提升团队效率。</p><p>而在团队不忙的时候，需要相互学习，相互取经。</p><h3 id="责任到人"><a href="#责任到人" class="headerlink" title="责任到人"></a>责任到人</h3><p>比如重要营销活动的模块，就需要专门的团队或者个人来负责。在当时，我们团队我就专门找了一个细心的人，专门负责月度营销活动功能开发。从产品需求会议到活动的产出，都有该同事整体跟进与负责。</p><h3 id="砍掉老鼠屎"><a href="#砍掉老鼠屎" class="headerlink" title="砍掉老鼠屎"></a>砍掉老鼠屎</h3><p>花成本砍掉那些搞崩心态的员工，给予机会，并加以说明，如果最后还是没有无效果，可以选择优化掉，不要低估一个人对团队的破坏能力。</p><p><strong>事情不是一个人能做好的， 根据团队成员来扬长避短，团队效率才会蹭蹭的上去。</strong></p><h2 id="一起抗"><a href="#一起抗" class="headerlink" title="一起抗"></a>一起抗</h2><p>最后的最后，也是最重要的，遇到事情，一定要和兄弟们一起抗。</p><p>不要领导说什么什么问题，你就很干脆利落的直接甩锅给你的团队成员，我见过不少这样子的中层领导，他只管自己在领导眼中印象，而不管自己兄弟的利益，还是那句话，<strong>中层的能力就是掌握平衡的能力（正确的废话）</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这篇文章到这里就写完了，这篇文章中心思想就是<strong>以自己的亲生经历总结的中层管理者的那些心法与做法</strong>，希望对你有帮助，如果觉得哪里不合理的地方，也可以留言告诉我。</p><p>​    衷心感谢每一位认真读文章的人，我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p>]]></content>
    
    
    <categories>
      
      <category>团队管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cms回收为什么要停顿两次？</title>
    <link href="/java/5dd56976329d.html"/>
    <url>/java/5dd56976329d.html</url>
    
    <content type="html"><![CDATA[<h2 id="cms回收为什么要停顿两次？"><a href="#cms回收为什么要停顿两次？" class="headerlink" title="cms回收为什么要停顿两次？"></a>cms回收为什么要停顿两次？</h2><p><strong>答案：</strong>以最少的STW成本，找出要清理的垃圾。</p><h3 id="什么是STW"><a href="#什么是STW" class="headerlink" title="什么是STW"></a>什么是STW</h3><p>暂停用户线程 - <strong>Stop The World</strong></p><h3 id="为什么要STW"><a href="#为什么要STW" class="headerlink" title="为什么要STW"></a>为什么要STW</h3><p>如果不暂停用户线程，就意味着不断有垃圾的产生，永远也清理不干净；</p><p>其次，因为清理垃圾用的标记清除算法，用户线程的运行必然会导致对象的引用关系发生变化，即标记的变化，，这样就会导致两种情况：漏标和错标。</p><ol><li><strong>漏标：</strong>原来不是垃圾，但是在GC的过程中，用户线程将其引用关系修改，变成了null引用，成为了垃圾，这种情况还好，无非就是产生了一些浮动垃圾，下次GC再清理就好了；</li><li><strong>错标：</strong>与漏标对应的就是错标，一个对象，开始没有引用，但是GC的同时，用户线程又重新引用了它，但是这个时候，我们把它当作垃圾清理掉了，这将会导致程序运行错误。</li></ol><h3 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h3><p>前边讲了两点，什么是暂停用户线程和为什么要暂停用户线程，现在接着讲cms是怎么样来识别垃圾对象的。</p><p><strong>垃圾对象：</strong>简单的说，就是判断是否有引用，如果某个对象，已经没有任何引用指向它，就把该对象定义为垃圾对象，即我们要清理的对象，这个的核心就是可达性分析算法。</p><p><strong>标记步骤：</strong></p><ol><li>开所有的对象都是白色</li><li>直接关联的对象设置为灰色</li><li>遍历灰色对象的所有引用，灰色对象本身置为黑色，引用置为灰色</li><li>重复步骤3，直到没有灰色对象为止</li><li>结束时，黑色对象存活，白色对象回收</li></ol><p><strong>这个过程正确执行的前提是没有其他线程改变对象间的引用关系。</strong></p><h3 id="cms清理步骤"><a href="#cms清理步骤" class="headerlink" title="cms清理步骤"></a>cms清理步骤</h3><p><img src="http://mkstatic.lianbian.net/20210913155000.png" alt="cms清理步骤"></p><ol><li>初试标记</li></ol><p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。初始标记的过程是需要触发STW的，不过这个过程非常快，而且初试标记的耗时不会因为堆空间的变大而变慢，是可控的，因此可以忽略这个过程导致的短暂停顿。</p><ol start="2"><li>并发标记</li></ol><p>并发标记就是将初始标记的对象进行深度遍历，以这些对象为根，遍历整个对象图，这个过程耗时较长，而且标记的时间会随着堆空间的变大而变长。不过好在这个过程是不会触发STW的，用户线程仍然可以工作，程序依然可以响应，只是程序的性能会受到一点影响。因为GC线程会占用一定的CPU和系统资源，对处理器比较敏感。CMS默认开启的GC线程数是：(CPU核心数+3)/4，当CPU核心数超过4个时，GC线程会占用不到25%的CPU资源，如果CPU数不足4个，GC线程对程序的影响就会非常大，导致程序的性能大幅降低。</p><ol start="3"><li>重新标记</li></ol><p>由于并发标记时，用户线程仍在运行，这意味着并发标记期间，用户线程有可能改变了对象间的引用关系，可能会发生两种情况：一种是原本不能被回收的对象，现在可以被回收了，另一种是原本可以被回收的对象，现在不能被回收了。针对这两种情况，CMS需要暂停用户线程，进行一次重新标记。</p><ol start="4"><li>并发清理</li></ol><p>重新标记完成后，就可以并发清理了。这个过程耗时也比较长，且清理的开销会随着堆空间的变大而变大。不过好在这个过程也是不需要STW的，用户线程依然可以正常运行，程序不会卡顿，不过和并发标记一样，清理时GC线程依然要占用一定的CPU和系统资源，会导致程序的性能降低。</p><h3 id="cms为什么要停顿两次？"><a href="#cms为什么要停顿两次？" class="headerlink" title="cms为什么要停顿两次？"></a>cms为什么要停顿两次？</h3><p>以最少的STW成本，找出要清理的垃圾。</p><p>这里我们可以抽象的理解为<strong>全量垃圾</strong>和<strong>增量垃圾</strong>的两个概念。</p><p>清理的第一步，就是为了找出<strong>产生全量垃圾根对象</strong>，并打上标记为<strong>初始标记（耗时短，STW）</strong>，同时把用户访问线程打开，并让后台线程去执行第二步<strong>并发标记</strong>，这些其实就是找出我们<strong>全量垃圾</strong>。</p><p>然后找出在我们执行<strong>并发标记</strong>这段时间由用户线程产生的<strong>增量垃圾</strong>进行<strong>重新标记（耗时短，STW）</strong>，这个时候的GC标记，就是截止到当前时间，完整的垃圾信息，再执行<strong>并发清理</strong>。</p><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><p><a href="https://zhuanlan.zhihu.com/p/340530051">CMS与三色标记算法</a></p><p><a href="https://www.jianshu.com/p/12544c0ad5c1">三色标记与读写屏障</a></p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203152301257.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手把手教你实现两阶段提交</title>
    <link href="/java/236c4f4e7821.html"/>
    <url>/java/236c4f4e7821.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天这篇文章给大家讲解广义上的两阶段提交。</p><p>阅读本篇文章大约需要<strong>10分钟</strong>。</p><p>文章分为理论和实战部分，理论部分讲述两阶段提交的概念与实现方式；通过理论的铺垫之后，实战部分我们会动手写代码、创建数据库，实战一个银行转账的案例，希望通过这个案例，更通透理解两阶段提交。</p><h2 id="文章导读"><a href="#文章导读" class="headerlink" title="文章导读"></a>文章导读</h2><p><img src="http://mkstatic.lianbian.net/202110031042434.png" alt="两阶段提交"></p><h2 id="理论概述"><a href="#理论概述" class="headerlink" title="理论概述"></a>理论概述</h2><h3 id="分布式一致性"><a href="#分布式一致性" class="headerlink" title="分布式一致性"></a>分布式一致性</h3><p>分布式场景下，多个服务同时对服务一个流程，比如电商下单场景，需要支付服务进行支付、库存服务扣减库存、订单服务进行订单生成、物流服务更新物流信息等。如果某一个服务执行失败，或者网络不通引起的请求丢失，那么整个系统可能出现数据不一致的原因。</p><p>上述场景就是分布式一致性的问题，其根本原因在于数据的分布式操作，引起本地事务无法保障数据的原子性。</p><p>分布式一致性问题的解决思路有两种，一种是<strong>分布式事务</strong>，一种是尽量通过业务流程避免分布式事务。</p><p><strong>分布式事务</strong>是直接解决问题，而业务规避其实是通过解决出问题的地方。</p><p>在真实的业务场景中，最优雅的解决方案就是业务规避。</p><h3 id="分布式事务分类"><a href="#分布式事务分类" class="headerlink" title="分布式事务分类"></a>分布式事务分类</h3><p>分布式事务实现方案从类型上分为刚性事务和柔性事务。</p><p>刚性事务：通常无业务改造，强一致性，原生支持回滚/隔离性，低并发，适合短事务<code>（XA协议（2PC、JTA、JTS）、3PC）</code>；</p><p>柔性事务：有业务改造，最终一致性，实现补偿接口，实现资源锁定接口，高并发，适合长事务<code>(TCC/FMT、Saga(状态机模式，Aop模式)、本地事务消息、消息事务（半消息）、最多努力通知型事务)</code>；</p><h3 id="2PC定义（二阶段定义）"><a href="#2PC定义（二阶段定义）" class="headerlink" title="2PC定义（二阶段定义）"></a>2PC定义（二阶段定义）</h3><figure class="highlight plaintext"><figcaption><span>是指在```计算机网络```以及```数据库```领域内，为了使基于```分布式系统```架构下所有节点在进行事务提交时保持一致性而设计的一种算法。通常，二阶段提交也被称为一种协议。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs 二阶段提交```"><br>在我们的分布式系统中，每个节点虽然可以知道自己的操作成功或者失败，但是不知道其他的节点的成功或者失败，当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终决定这些节点是否要进行真正的提交。这里可以回忆下redo log和binlog的两阶段提交。<br><br>因此，二阶段提交的算法思路可以概括为：**参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈结果决定各参与者是否要```提交操作```还是```回滚操作```。**<br><br><br><br>## 第一阶段（提交请求阶段）<br><br>1. 协调者节点向所有参与者节点询问是否可以执行提交操作，并**开始等待各参与节点的响应**；<br>2. 参与者节点执行协调者节点询问发起的所有事务操作；<br>3. 各参与节点响应协调者节点发起的询问。如果参与者节点的事务执行成功，则它返回一个“YES”消息；如果参与者节点事务执行失败，则返回一个“NO”消息。<br><br>第一阶段，也被称为**投票阶段**，即各个参与者投票是否要继续接下来的提交操作。<br><br><br><br>## 第二阶段（提交执行阶段）<br><br>### 成功则提交<br><br>当协调者节点从所有参与者节点获得的响应消息都为“YES”时：<br><br>1. 协调者节点向所有参与者节点发出“正式提交”的请求；<br>2. 参与者节点正式完成操作，并释放在整个事务期间内占用的资源；<br>3. 参与者节点向协调者节点发送“完成”消息；<br>4. 协调者节点收到所有参与者节点的“完成”消息后，完成事务。<br><br>### 失败则回滚<br><br>如果任一参与者节点在第一阶段返回的消息为“NO”，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：<br><br>1. 协调者节点向所有参与者节点发出“回滚操作”的请求；<br>2. 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源；<br>3. 参与者节点向协调者节点发送“回滚完成”消息；<br>4. 协调者节点收到所有参与者节点的“完成”消息，取消事务。<br><br>第二阶段，也被称为**完成阶段**，因为无论结果怎样，协调者都必须在此阶段结束当前事务。<br><br><br><br>## 二阶段流程图<br><br>![2PC流程图](http://mkstatic.lianbian.net/202109281526655.png)<br><br><br><br>## 实战<br><br>### 实战概述<br><br>通过对二阶段提交的理论讲解，想必对什么是二阶段提交有所了解，接下来通过一个银行转账的案例，来实战一个二阶段提交，让你彻底搞懂二阶段提交。<br><br>案例：**ABC公司**为其客户提供银行转账业务，假设连边是该公司的客户，需要从连边在**中国银行的工资卡**上提取3000元到连边在**建设银行的房贷卡**上，用来还房贷。<br><br>想一想，结合上边的理论部分，这个案例中，哪些是**协调者**，哪些是**参与者**？<br><br>**ABC公司**为协调者，连边的**中国银行**和**建设银行**为参与者。<br><br><br><br>### 实战流程图<br><br>![实战流程图](http://mkstatic.lianbian.net/202109281533996.png)<br><br><br><br>### 模块设计<br><br>**环境：**<br><br>- ```java1.8+```  <br><br>- ```maven```<br>- ```mysql```<br><br>**模块划分：**<br><br>1. 公用模块（bank-common）<br>2. 客户（customer-client）<br>3. 建设银行服务（ccb-server）<br>4. 中国银行服务（boc-server）<br>5. ABC公司 - TM协调者（transaction-manager）<br>6. 协议封装（protocol）<br><br><br><br>### 数据库设计<br><br>**建设银行（ccb-server）**<br><br>![ccb数据库视图](http://mkstatic.lianbian.net/202109281800842.png)<br><br>**中国银行（boc-server）**<br><br>![boc数据库视图](http://mkstatic.lianbian.net/202109281801752.png)<br><br>**ABC公司 - TM协调者（transaction-manager）**<br><br>![TM数据库视图](http://mkstatic.lianbian.net/202109281801517.png)<br><br><br><br>### 源码<br><br>阅读源码，从```客户（customer-client）```项目入口开始阅读，关键的地方，我都加上了注释，整体源码读下来可能需要一点时间，但是对我们理解```2pc```有意义。<br><br>**阅读源码的几个关键点：**<br><br>1. 源码整体都是通过```Handler + command```的来连接处理逻辑的，如：<br><br>```java<br>// TRANSACTION_REQ_COMMAND = transactionReq<br>final String httpURL = getHttpURL(node, Constants.TRANSACTION_REQ_COMMAND);<br></code></pre></td></tr></table></figure><p>当看到上边这段代码，你就要去找<code>TransactionRequestHandler.class</code>，这里为了方便跟踪，定义了常量，idea环境可以直接通过跟踪常量跟踪到具体的代码位置。</p><ol start="2"><li>采用Java并发编程中的<code>CountDownLatch</code>，阅读的时候留意下</li></ol><p><strong>完整的源码，关注「连边」公众号，回复<code>2pc</code> 即可获取，观看源码的<code>README.md</code> 能够运行。</strong></p><p><strong>运行截图：</strong></p><ol><li>打包</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">需要替换自己的项目路径</span><br>cd /Library/WebServer/Documents/java/lianbian-2pc<br>mvn -Dmaven.test.skip=true package<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/202110031007161.png" alt="打包成功截图"></p><ol start="2"><li>启动服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 BOC server</span><br>java -Xms256M -Xmx256m -jar /Library/WebServer/Documents/java/lianbian-2pc/boc-server/target/boc-server-1.0-SNAPSHOT.jar<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 CCB server</span><br>java -Xms256M -Xmx256m -jar /Library/WebServer/Documents/java/lianbian-2pc/ccb-server/target/ccb-server-1.0-SNAPSHOT.jar<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 Transaction Manager server</span><br>java -Xms256M -Xmx256m -jar /Library/WebServer/Documents/java/lianbian-2pc/transaction-manager/target/transaction-manager-1.0-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/202110031006015.png" alt="启动服务成功截图"></p><ol start="3"><li>模拟转账</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">模拟转账</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数：转出银行  转出账号  转入银行  转入账号  转账金额</span><br>java -Xms256M -Xmx256m -jar /Library/WebServer/Documents/java/lianbian-2pc/customer-client/target/customer-client-1.0-SNAPSHOT.jar BOC 1 CCB 2 20000<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/202110031011094.png" alt="交易成功"></p><p><img src="http://mkstatic.lianbian.net/202110031011223.png" alt="交易失败，余额不足"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这篇文章到这里就写完了，这篇文章其实很早就着手准备，但是在写的时候，还是感觉效率不高，要想一想怎么<strong>提升效率</strong>这个事情了。</p><p>​    <strong>完整的源码，关注「连边」公众号，回复<code>2pc</code> 即可获取，观看源码的<code>README.md</code> 能够运行。</strong></p><p>​    衷心感谢每一位认真读文章的人，我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203182126361.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>mysql</tag>
      
      <tag>2pc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的redo log和binlog日志</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93/8a4432e16eb7.html"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/8a4432e16eb7.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天这篇文章给大家带来MySQL中重要的两个日志 - <code>redo log、binlog</code>，从理论概念出发，结合图解分析，看完这篇文章之后，你能对<code>redo log、binlog</code>有深入的理解。</p><h2 id="文章框架图"><a href="#文章框架图" class="headerlink" title="文章框架图"></a>文章框架图</h2><p><img src="http://mkstatic.lianbian.net/20210915164447.png" alt="MySQL两个日志"></p><h2 id="浅谈MySQL分层架构"><a href="#浅谈MySQL分层架构" class="headerlink" title="浅谈MySQL分层架构"></a>浅谈MySQL分层架构</h2><p>在讲具体的日志之前，先稍微铺垫下MySQL分层的架构，让大家知道<code>redo log、binlog</code>是由MySQL的哪一层产生的。</p><p><img src="http://mkstatic.lianbian.net/20210915095746.png" alt="MySQL分层架构图"></p><p>Mysql整体分为3层：客户端层，Server层和存储引擎层。我们的binlog日志，由Server层生成，redo log是innodb特有的日志，由innodb引擎生成。</p><h2 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a>重做日志（redo log）</h2><h3 id="什么是redo-log"><a href="#什么是redo-log" class="headerlink" title="什么是redo log"></a>什么是redo log</h3><p>innodb为了能够支持事务一系列操作，而事务有4种特性：<code>原子性、一致性、隔离性、持久性</code>，在事务操作中，要么全部执行，要么全部不执行，这就是事务的目的。而我们的redo log用来保证事务的持久性，即我们常说的ACID中的D。我们只需要知道它是通过一套什么样的机制，来保证持久性，就能掌握好redo log。</p><p>这里的说的持久性，是说最后落盘到redo log文件中（即常见的<code>ib_logfile</code>文件），因为最后我们异常情况的恢复，都是根据文件来做恢复的。</p><p>MySQL innodb是通过一套什么样的机制，来确保<strong>速度</strong>与<strong>redo log的可靠性</strong>的呢？</p><h3 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h3><p>在计算机体系中，CPU处理速度和硬盘的速度，是不在同一个数量级上的，为了让它们速度匹配，从而催生了我们的内存模块，但是内存有一个特点，就是掉电之后，数据就会丢失，不是持久的，我们需要持久化的数据，最后都需要存储到硬盘上。</p><p>innodb引擎设计者也利用了类似的设计思想，先写内存，再写硬盘，这样子就不会因为redo log而导致数据库性能问题。而在innodb中，这种技术有一个专业名称，叫做<strong>Write-Ahead Log（预先日志持久化）</strong></p><p><img src="http://mkstatic.lianbian.net/20210915103820.png" alt="先写buffer 再写磁盘"></p><h3 id="redo-log写入策略"><a href="#redo-log写入策略" class="headerlink" title="redo log写入策略"></a>redo log写入策略</h3><p>上边是保证了处理的速度，但是怎么样保证写入到硬盘的可靠性呢？</p><p>InnoDB引擎的设计者也设计了一种写入的策略，首先有一个后台线程，每隔1秒，就会把<code>redo log buffer</code>中的日志，调用write写到文件系统的<code>page cache</code>，然后调用<code>fsync</code>持久化到磁盘（即redo log文件 <code>ib_logfile0 ib_logfile1 </code>）。</p><p>为了控制 redo log写入策略，InnoDB提供了<code>innodb_flush_log_at_trx_commit</code>配置参数，它有三种取值：</p><ol><li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li><li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p><strong>如果不是对性能要求高的，一般把该参数设置为 1</strong></p><h3 id="redo-log的擦除"><a href="#redo-log的擦除" class="headerlink" title="redo log的擦除"></a>redo log的擦除</h3><p>通过上边的设计，<strong>速度</strong>和<strong>可靠性</strong>的问题都解决了，但是我们仔细想想，还会有什么问题？</p><p>随着文件的增加，落盘的速度会越来越慢，直到有一天 … </p><p>聪明的设计者这样子想着，如果我一直处理小文件，最大不能超过某个大小，不就行了？</p><p>也确实是这样子处理的，但是这里就涉及到一个删除日志文件的算法，即我们的<strong>redo log擦除</strong>。</p><p>redo log 的大小是固定的，比如可以配置一组4个文件，每个文件大小是8M，那么这个redo log总共就可以记录32M的操作，这个参数可以通过<code>innodb_log_file_size</code>设置。</p><p>下图是具体的擦除算法，ib_logfile 从头开始写，写到末尾就又回到开头循环写。</p><p><img src="http://mkstatic.lianbian.net/20210910212751.png" alt="擦除示意图 - 来自丁奇MySQL连边编辑"></p><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后移动并且循环的，擦除记录前要把记录更新到数据文件，write pos与check point之间为剩余可用写入的空间。</p><p>何时会擦除redo log并更新到数据文件中</p><ol><li>系统空闲时</li><li>Redo log文件没有空闲空间时，即write pos追上check point的时候；</li><li>MySQL Server正常关闭时</li></ol><h3 id="crash-safe"><a href="#crash-safe" class="headerlink" title="crash-safe"></a>crash-safe</h3><p>有了以上这一些机制保障，我们可以相信redo log是可靠的，只要持久化到redo log文件中了，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，而我们把这个能力称为 <code>crash-safe</code>。</p><h2 id="归档日志（binlog）"><a href="#归档日志（binlog）" class="headerlink" title="归档日志（binlog）"></a>归档日志（binlog）</h2><p>在写这篇文章的时候，纠结到底先写redo log还是binlog，最后还是秉承<strong>先苦后甜</strong>的原则，把redo log写在前面了。如果redo log的部分看懂了，binlog掌握是轻松的，跟着我的思路，我们继续binlog～</p><p>前边讲过，redo log是InnoDB引擎特有的日志，是引擎层面的日志，而在我们的数据库的Server层面，也有自己的日志，称为binlog（归档日志）。</p><p>binlog是逻辑日志，怎么样来理解这个<strong>逻辑日志</strong>呢？</p><p>我们通过查看一段binlog来理解。</p><h3 id="理解逻辑日志"><a href="#理解逻辑日志" class="headerlink" title="理解逻辑日志"></a>理解逻辑日志</h3><p><strong>这里一大段的操作，都是为了查看binlog文件里边存储的是什么内容，熟悉的读者可以直接略过。</strong></p><p>执行命令，写入新binlog文件，不让之前的逻辑影响。</p><p>执行一次flush logs命令行，就会在data目录下新增一个mysql-bin.00000x文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 登陆MySQL命令行</span></span><br>mysql -uroot -p<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 刷新binlog</span></span><br>flush logs;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 确认刷新binlog成功</span></span><br>show master status;<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 查询binlog日志位置</span></span><br> show variables like&#x27;log_bin%&#x27;;<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210915113418.png" alt="data目录下的mysql-bin文件"></p><p>测试数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">## 创建表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">User</span>`  (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> gb2312 <span class="hljs-keyword">COLLATE</span> gb2312_chinese_ci <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_bin ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br><br>## 新增<br><span class="hljs-keyword">INSERT</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">VALUES</span>(&quot;1&quot;, &quot;张三&quot;, <span class="hljs-number">18</span>);<br><span class="hljs-keyword">INSERT</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">VALUES</span>(&quot;2&quot;, &quot;李四&quot;, <span class="hljs-number">20</span>);<br>## 修改<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">User</span>` <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210915143958.png" alt="执行语句截图"></p><p>翻译binlog二进制文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo /usr/local/mysql/bin/mysqlbinlog --base64-output=DECODE-ROWS -v mysql-bin.000006 &gt; mysqlbin.sql<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210915144240.png" alt="binlog翻译"></p><p>这是翻译出来的sql文件，是因为我在<code>mysqlbinlog -v</code>参数加工而成的。</p><p><strong>由此可知，逻辑日志里边就是记录着sql语句，通过sql语句记录着逻辑的变化，比如insert, update等动作，但不是记录具体数据，那个由物理日志完成。</strong></p><h3 id="与redo-log的区别"><a href="#与redo-log的区别" class="headerlink" title="与redo log的区别"></a>与redo log的区别</h3><ol><li>redo log是innoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都能使用；</li><li>redo log是循环写的，空间固定会用完；binlog是追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><h3 id="binlog写入策略"><a href="#binlog写入策略" class="headerlink" title="binlog写入策略"></a>binlog写入策略</h3><p>通过与redo log的区别，我们知道，binlog是追加写入的，所以与redo log写入相比，没有擦除的概念。那么，还有一些什么样的其他的区别呢？</p><p>binlog的写入逻辑比较简单：事务执行过程中，先把日志写到binlog cahce，事务提交的时候，再把binlog cache写到binlog文件中（落盘）。</p><p><img src="http://mkstatic.lianbian.net/20210915213519.png" alt="binlog写入"></p><p>从上图可以看到，每个线程都有自己的binlog cache，但是共用同一份binlog文件。</p><p>图中的write，指的就是把日志写入到围巾啊系统的page cache，并没有把数据持久化到磁盘，所有速度很快；</p><p>途中的sync，才是将数据持久化到磁盘的操作。</p><p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p><p>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</p><p>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</p><p>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</p><blockquote><p>因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。</p><p>但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p><p>引用《极客时间MySQL45讲》</p></blockquote><h2 id="浅谈两阶段提交"><a href="#浅谈两阶段提交" class="headerlink" title="浅谈两阶段提交"></a>浅谈两阶段提交</h2><p>这里讲的两阶段提交，就是纯粹的指redo log和binlog日志的两阶段提交。</p><p>而两阶段提交的目的就是让redo log和binlog两个日志逻辑上一致。</p><p>如果redo log持久化并进行了提交，而binlog未持久化数据库就crash了，则从库从binlog拉取数据会少于主库，造成不一致。因此需要内部事务来保证两种日志的一致性。</p><h3 id="两阶段提交步骤"><a href="#两阶段提交步骤" class="headerlink" title="两阶段提交步骤"></a>两阶段提交步骤</h3><p><img src="http://mkstatic.lianbian.net/20210915171349.png" alt="两阶段提交"></p><ol><li>将语句执行</li><li>记录redo log，并将记录状态设置为prepare</li><li>通知Server，已经修改好了，可以提交事务了</li><li>将更新的内容写入binlog</li><li>commit，提交事务</li><li>将redo log里这个事务相关的记录状态设置为commited</li></ol><p><strong>prepare：</strong>redolog写入log buffer，并fsync持久化到磁盘，在redolog事务中记录2PC的XID，在redolog事务打上prepare标识<br><strong>commit：</strong>binlog写入log buffer，并fsync持久化到磁盘，在binlog事务中记录2PC的XID，同时在redolog事务打上commit标识<br>其中，prepare和commit阶段所提到的“事务”，都是指内部XA事务，即2PC</p><h3 id="恢复步骤"><a href="#恢复步骤" class="headerlink" title="恢复步骤"></a>恢复步骤</h3><p>redolog中的事务如果经历了二阶段提交中的prepare阶段，则会打上prepare标识，如果经历commit阶段，则会打上commit标识（此时redolog和binlog均已落盘）。</p><ol><li>按顺序扫描redolog，如果redolog中的事务既有prepare标识，又有commit标识，就直接提交（复制redolog disk中的数据页到磁盘数据页）</li><li>如果redolog事务只有prepare标识，没有commit标识，则说明当前事务在commit阶段crash了，binlog中当前事务是否完整未可知，此时拿着redolog中当前事务的XID（redolog和binlog中事务落盘的标识），去查看binlog中是否存在此XID<ol><li>如果binlog中有当前事务的XID，则提交事务（复制redolog disk中的数据页到磁盘数据页）</li><li>如果binlog中没有当前事务的XID，则回滚事务（使用undolog来删除redolog中的对应事务）</li></ol></li></ol><p>可以将mysql redolog和binlog二阶段提交和广义上的二阶段提交进行对比，广义上的二阶段提交，若某个参与者超时未收到协调者的ack通知，则会进行回滚，回滚逻辑需要开发者在各个参与者中进行记录。mysql二阶段提交是通过xid进行恢复。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203182128339.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不重启JVM替换掉已经加载的类</title>
    <link href="/java/8cd76013616c.html"/>
    <url>/java/8cd76013616c.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>我们工作中，时常会碰到样的问题，测试环境、预发布环境都好好的，但是代码一到线上就莫名其妙的出问题了。往往这个时候，我们不能中断对外提供服务，又要调试线上问题，怎么办呢？</p><p>我们首先分析一下，其实我们这个问题的本质是<strong>要动态改变内存中已存在的对象的行为</strong>。</p><p>我们知道，JVM的操作对象是class文件，而不是源码。</p><p>所以进一步分析，<strong>改变class文件，然后让JVM重新加载class文件就能达到我们的目的。</strong></p><h2 id="github文档"><a href="#github文档" class="headerlink" title="github文档"></a>github文档</h2><p>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p><p><a href="https://github.com/alibaba/arthas/blob/master/README_CN.md">https://github.com/alibaba/arthas/blob/master/README_CN.md</a></p><h2 id="Arthas实战"><a href="#Arthas实战" class="headerlink" title="Arthas实战"></a>Arthas实战</h2><h3 id="start-demo"><a href="#start-demo" class="headerlink" title="start demo"></a>start demo</h3><ol><li>利用spring boot 在本地启动一个服务，端口：61000</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// demo-arthas-spring-boot.jar 关注“连边”订阅号，回复“arthas”获取jar包</span><br>java -jar demo-arthas-spring-boot.jar<br></code></pre></td></tr></table></figure><ol start="2"><li>启动后如图：</li></ol><p><img src="http://mkstatic.lianbian.net/20210907220553.png" alt="spring boot 启动图"></p><ol start="3"><li>测试是否启动成功：</li></ol><p><img src="http://mkstatic.lianbian.net/20210907220707.png" alt="image-20210907220707380"></p><h3 id="start-arthas"><a href="#start-arthas" class="headerlink" title="start arthas"></a>start arthas</h3><p>新开一个命令行窗口，启动arthas</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 启动arthas 关注“连边”订阅号，回复“arthas”获取jar包</span><br>java -jar arthas-boot.jar<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210907220915.png" alt="输入命令行"></p><p>这里选择[2]，因为[2]是我刚启动的进程</p><p><img src="http://mkstatic.lianbian.net/20210907221107.png" alt="选择指定进程"></p><p>至此，准备工作完毕，第二个窗口也进入到<code>arthas</code>窗口模式。</p><h3 id="热更新代码"><a href="#热更新代码" class="headerlink" title="热更新代码"></a>热更新代码</h3><ol><li>通过浏览器访问： <a href="http://localhost:61000/user/0">http://localhost:61000/user/0</a> 会抛出500的错误</li><li>反编译文件到 <code>/tmp/UserController.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// jad反编译UserController并保存在 /tmp/UserController.java</span><br>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java<br></code></pre></td></tr></table></figure><ol start="3"><li>另外启动一个命令行窗口来编辑文件 <code>/tmp/UserController.java</code>比如当 user id 小于1时，也正常返回，不抛出异常：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">vim /tmp/UserController.java<br><br><span class="hljs-meta">@GetMapping(value=&#123;&quot;/user/&#123;id&#125;&quot;&#125;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUserById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;<br>  logger.info(<span class="hljs-string">&quot;id: &#123;&#125;&quot;</span>, (Object)id);<br>  <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span> &amp;&amp; id &lt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(id, <span class="hljs-string">&quot;name&quot;</span> + id);<br>    <span class="hljs-comment">// throw new IllegalArgumentException(&quot;id &lt; 1&quot;);</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(id.intValue(), <span class="hljs-string">&quot;name&quot;</span> + id);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210907222450.png" alt="编辑代码行数"></p><ol start="4"><li>sc查找加载UserController的classLoaderHash</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">sc -d *UserController | grep classLoaderHash<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210907222520.png" alt="classLoaderHash"></p><ol start="5"><li>通过<code>mc -c &lt;classLoaderHash&gt; /tmp/UserController.java -d /tmp</code>，使用<code>-c</code>参数指定ClassLoaderHash:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">mc -c 33c7353a /tmp/UserController.java -d /tmp<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210907222641.png" alt="mc命令行效果"></p><ol start="6"><li>再使用<code>redefine</code>命令重新加载新编译好的<code>UserController.class</code>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">redefine /tmp/com/example/demo/arthas/user/UserController.class<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/20210907222757.png" alt="redefine命令行效果"></p><ol start="7"><li><code>redefine</code>成功之后，再次访问 user/0 ，结果是：</li></ol><p><img src="http://mkstatic.lianbian.net/20210907222858.png" alt="替换之后的效果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java是静态语言，运行时不允许改变数据结构。</p><p>然而，Java 5引入Instrument，Java 6引入Attach API之后，事情开始变得不一样了。</p><p>虽然存在诸多限制，然而，在前辈们的努力下，仅仅是利用预留的近似于“只读”的这一点点狭小的空间，仍然创造出了各种技术，极大地提高了软件开发人员定位问题的效率。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="https://mkstatic.lianbian.net/202203182121893.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>arthas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinkedList源码解析</title>
    <link href="/java/4ed0ad3cd54d.html"/>
    <url>/java/4ed0ad3cd54d.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><p>今天七夕情人节，在这里祝天下有情人终成眷属。</p><h2 id="且以深情共白首"><a href="#且以深情共白首" class="headerlink" title="且以深情共白首"></a>且以深情共白首</h2><p>让自己的另一半了解自己的职业，还是挺重要的。</p><p>朋友眼中的我：修电脑的；</p><p>爸妈眼中的我：熬夜加班的栋梁材；</p><p>岳父岳母眼中的我：没有铁饭碗的不靠谱青年。</p><p>亲身经历证明，这些都不重要，身为一名神秘而复杂的程序员，你只需要得到你最在乎的那个人的理解和认可就行了。</p><p>靠什么？必须是才华和深情。</p><p>狗子们，我们一起来用链表定制一辆幸福号地铁送给心目中的那个她吧，奔赴星辰大海，白首不离。</p><h2 id="地铁站链表"><a href="#地铁站链表" class="headerlink" title="地铁站链表"></a>地铁站链表</h2><p>我们先以长沙地铁一号线的地铁站名来分析链表的制作过程。</p><p><img src="http://mkstatic.lianbian.net/20210814154739.jpeg" alt="长沙地铁一号线"></p><p><strong>“培元桥到了，下一站：五一广场，请前往五一广场的乘客做好下车准备。”</strong></p><p>培元桥站的图示：</p><p><img src="http://mkstatic.lianbian.net/20210814155418.png" alt="站点图片"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 抽象```一下的站点示意图："><br>&lt;img src=&quot;http://mkstatic.lianbian.net/20210814095804.png&quot; alt=&quot;image-20210814095804012&quot;/&gt;<br><br>用代码来定义这个车站：<br><br>```java<br>class Station&lt;E&gt; &#123;<br>    // 车站本身<br>    E item;<br>    // 下一站<br>    Node&lt;E&gt; next;<br><br>    public Station(E item, Node&lt;E&gt; next) &#123;<br>      this.item = item;<br>      this.next = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据这个上边讲解，我们不难总结出其特点：<strong>站点不仅包含了自身的信息，还包含了下一站信息。</strong></p><p>通过上边的车站节点，我们画出其他站点示意图（画出4个，不全部画出。）</p><img src="http://mkstatic.lianbian.net/20210814101424.png" alt="站点图片"  /><p>如果要让车站信息更实用，使之富有动态感，对乘客的提示性更强，我们就需要把它们链接起来，成为实用的数据结构，像一号线交通站点图那样。</p><p><img src="http://mkstatic.lianbian.net/20210814111856.gif" alt="站点链表"></p><h3 id="定义地铁链表"><a href="#定义地铁链表" class="headerlink" title="定义地铁链表"></a>定义地铁链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StationList</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 站点总数</span><br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-comment">// 第一站</span><br>    Station&lt;E&gt; first;<br>    <span class="hljs-comment">// 最后一站</span><br>    Station&lt;E&gt; last;<br><br>    <span class="hljs-comment">// 车站，就是上边抽象的那个车站结构</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Station</span>&lt;E&gt; &#123;<br>        <span class="hljs-comment">// 本车站信息</span><br>        E item;<br>        <span class="hljs-comment">// 下一站车站信息</span><br>        Station&lt;E&gt; next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Station</span><span class="hljs-params">(E item, Station&lt;E&gt; next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Station&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Station&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Station</span>&lt;&gt;(e, <span class="hljs-literal">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>) &#123;<br>            first = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l.next = newNode;<br>        &#125;<br><br>        size++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-comment">// 循环从头开始找</span><br>        Station&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            x = x.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x.item;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="定制幸福号地铁"><a href="#定制幸福号地铁" class="headerlink" title="定制幸福号地铁"></a>定制幸福号地铁</h2><p>每个人对幸福的定义都不一样，那定制的站名就不一样。说到我的深情，简洁而温暖，温暖而持久。</p><blockquote><p>“我随时都有空。”</p><p>“娶到你像做梦一样。”</p><p>“工资转给你了。”</p><p>“崽睡了，我去买夜宵了。”</p><p>“我去背面试题了。”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    StationList&lt;String&gt; stationList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StationList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 初始化幸福号地铁链表</span><br>    stationList.add(<span class="hljs-string">&quot;我随时都有空。&quot;</span>);<br>    stationList.add(<span class="hljs-string">&quot;娶到你像做梦一样。&quot;</span>);<br>    stationList.add(<span class="hljs-string">&quot;工资转给你了。&quot;</span>);<br>    stationList.add(<span class="hljs-string">&quot;崽睡了，我去买夜宵了。&quot;</span>);<br>    stationList.add(<span class="hljs-string">&quot;我去背面试题了。&quot;</span>);<br><br>    System.out.printf(<span class="hljs-string">&quot;「幸福号地铁」共有 %s 站&quot;</span>, stationList.size);<br>    System.out.println();<br>    System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);<br>    System.out.printf(<span class="hljs-string">&quot;「幸福号地铁」从「%s」开往「%s」&quot;</span>, stationList.first.item, stationList.last.item);<br>    System.out.println();<br>    System.out.println(<span class="hljs-string">&quot;==========================&quot;</span>);<br>    System.out.printf(<span class="hljs-string">&quot;「幸福号地铁」告诉我们，幸福%d要素：&quot;</span>, stationList.size);<br>    System.out.println();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; stationList.size; i++) &#123;<br>      System.out.println(stationList.get(i));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="琴瑟在御，莫不静好"><a href="#琴瑟在御，莫不静好" class="headerlink" title="琴瑟在御，莫不静好"></a>琴瑟在御，莫不静好</h2><p>每个靠谱的人都值得拥有自己的幸福，用你的才华和深情去定制属于你们的幸福号地铁吧。</p><p>今天就别加班了。</p><p>毕竟，陪伴才是最长情的告白。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>关注 <code>订阅号@连边</code> 不错过精彩文章</p><p><img src="http://mkstatic.lianbian.net/202203082224370.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList源码解析</title>
    <link href="/java/9217b69cbb8b.html"/>
    <url>/java/9217b69cbb8b.html</url>
    
    <content type="html"><![CDATA[<p>大家好，我是连边。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始写<code>Java集合</code>图解源码系列的文章，本篇是开篇，主角是<code>ArrayList</code>。</p><p>这个系列按照这个步骤来讲解：</p><p><strong>图解分析原理，实战面试题检测，阅读JDK源码进一步巩固理解。</strong></p><p>阅读本系列文章，不需要数据结构的基础，带上认真的态度完全可以吃透。</p><h2 id="Java集合的整体认识"><a href="#Java集合的整体认识" class="headerlink" title="Java集合的整体认识"></a>Java集合的整体认识</h2><p>java集合框架提供了一套性能优良，使用方便的接口和类，它们位于<code>java.util</code>包中。</p><p><img src="http://mkstatic.lianbian.net/Java%E9%9B%86%E5%90%88.png" alt="Java集合"></p><p>今天这篇文章的主角是<code>ArrayList</code>，从上图可以看出，<code>ArrayList</code>实现List接口，和它同根同级的还有<code>LinkedList</code>，<code>ArrayList</code>同时还实现了RandomAccess, Cloneable, java.io.Serializable，我们利用类图来直观说明。</p><p><img src="http://mkstatic.lianbian.net/ArrayList-20210811144456212.png" alt="ArrayList类图"></p><h2 id="图解基本原理"><a href="#图解基本原理" class="headerlink" title="图解基本原理"></a>图解基本原理</h2><h3 id="数组与动态数组（ArrayList）"><a href="#数组与动态数组（ArrayList）" class="headerlink" title="数组与动态数组（ArrayList）"></a>数组与动态数组（ArrayList）</h3><p>数组的索引从0开始；</p><p>Java语言中提供的数组是用来储存固定大小的同类型元素；</p><p>Java中可以使用两种方式来声明数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 申明</span><br>String[] arrayRefVar;<br>String arrayRefVar[];<br></code></pre></td></tr></table></figure><p>Java中数组的创建方式同样有两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br><span class="hljs-type">int</span> <span class="hljs-variable">arraySize</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>String[] arrayRefVar = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[arraySize];<br><span class="hljs-comment">// 创建并且初始化</span><br>String[] arrayRefVar = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;;<br></code></pre></td></tr></table></figure><p>ArrayList是一种以数组实现的<code>List</code>，与数组相比，具有动态扩展的能力，因此也可称之为<code>动态数组</code>。</p><h3 id="增删改查和扩容"><a href="#增删改查和扩容" class="headerlink" title="增删改查和扩容"></a>增删改查和扩容</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><ol><li><p>末尾添加元素</p><p><strong>场景：</strong> 存在长度为6的数组，存在A、B、C三个值，把D值（索引为3）添加到数组末尾；</p><p><strong>步骤：</strong> 直接进行压入操作就可以完成操作，然后再挪动size；</p></li></ol><p><img src="http://mkstatic.lianbian.net/arrayList6.gif" alt="末尾添加元素"></p><ol start="2"><li><p>中间添加元素</p><p><strong>场景：</strong> 存在长度为6的数组，存在A、B、C三个值，把D值（索引为2）添加到AB之间；</p><p><strong>步骤：</strong> 首先需要把添加位置之后的元素往后挪，挪动完成之后，把指定的元素插入到挪出来的空位，然后挪动size；</p></li></ol><p><img src="http://mkstatic.lianbian.net/%E4%B8%AD%E9%97%B4%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.gif" alt="中间添加元素"></p><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><ol><li><p>删除末尾元素</p><p><strong>场景：</strong> 存在长度为6的数组，存在A、B、C三个值，把C值（索引为2）从数组中删除；</p><p><strong>步骤：</strong> 直接进行删除，然后挪动size；</p><p><img src="http://mkstatic.lianbian.net/%E5%88%A0%E9%99%A4%E6%9C%AB%E5%B0%BE%E5%85%83%E7%B4%A0.gif" alt="删除末尾元素"></p></li><li><p>删除中间元素</p><p><strong>场景：</strong> 存在长度为6的数组，存在A、B、C三个值，把B值（索引为1）从数组中删除；</p><p><strong>步骤：</strong> 找到指定索引的值，进行删除，把删除元素后边的元素依次往前挪，把最后一个元素设置为null，让他释放垃圾，然后移动size；</p><p><img src="http://mkstatic.lianbian.net/%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E5%85%83%E7%B4%A0.gif" alt="删除中间元素"></p></li></ol><h4 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h4><p><strong>场景：</strong> 存在长度为6的数组，存在A、B、C三个值，把B值（索引为2）修改成D值；</p><p><strong>步骤：</strong> 找到指定索引，把原来的值进行赋值，把新元素直接覆盖，返回oldValue；</p><p><img src="http://mkstatic.lianbian.net/%E4%BF%AE%E6%94%B9%E5%85%83%E7%B4%A0.gif" alt="修改元素"></p><h4 id="查询元素"><a href="#查询元素" class="headerlink" title="查询元素"></a>查询元素</h4><p><strong>场景：</strong> 存在长度为6的数组，存在A、B、C三个值，把B值（索引为2）；</p><p><strong>步骤：</strong> 找到指定索引，返回；</p><p><img src="http://mkstatic.lianbian.net/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0.gif" alt="获取元素"></p><h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>数组<code>ArrayList</code>是一种以数组实现的<code>List</code>，与数组相比，增删改查元素都一样，也需要<strong>连续的内存空间</strong>，但是它具有动态扩展的能力，因此也可称之为<code>动态数组</code>。</p><p>这里着重用动图表示动态数组的<strong>扩容机制</strong>，因为增删改查元素和数组是一样的，可以参照数组的动态图。</p><p><strong>场景：</strong> 存在长度为4的数组，存在A、B、C、D四个值，现在需要在最后添加元素，原来的长度不够，触发扩容机制；</p><p><strong>步骤：</strong> 按照原来数组长度的<strong>1.5倍</strong>创建一个新数组，即创建size=6的数组，把原来的old数组平移到新数组，size也进行同步平移，进行添加元素，然后修改数组的引用（由原来的old数组引用改成new数组引用）；</p><p><img src="http://mkstatic.lianbian.net/%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B91.gif" alt="数组扩容"></p><h3 id="数组特性与总结"><a href="#数组特性与总结" class="headerlink" title="数组特性与总结"></a>数组特性与总结</h3><ol><li>需要<strong>连续的内存空间</strong>来储存；</li><li>添加元素的性能，与添加元素位置有直接关系，末尾添加效率很高，越往前走效率越低（因为要移动元素），所以在<strong>不确定的添加位置场景下，不适合用数组</strong>，而储存固定大小的同类型的元素，可以选择用数组；</li><li><strong>查找效率高</strong>，根据索引能直接找出对应元素返回，找不到抛出对应异常；</li><li>扩容是按照<strong>原来数组容量（capacity）的一半</strong>扩容；</li><li>扩容是创建一个新数组，然后平移复制原来数组的方式，而不是直接在原来的数组后边直接扩容，这点是由于数组需要连续的内存空间决定的；</li></ol><p>通过上边的原理分析与总结，我们来<strong>实战面试题</strong>，来测试理论的掌握程度。</p><h2 id="实战面试题"><a href="#实战面试题" class="headerlink" title="实战面试题"></a>实战面试题</h2><ol><li>ArrayList的size和capacity怎么理解？</li><li>ArrayList内部是怎么存放数据的？</li><li>ArrayList的大小是如何自动扩容的？</li><li>在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？</li><li>ArrayList中的remove是如何操作的？</li><li>ArrayList的add操作优化？</li></ol><p>这是数组常见的面试题，你能手到擒来吗？</p><p>在文章的末尾会给出标准的答案，有不懂的题目也不着急看答案，我们继续<strong>阅读源码</strong>来巩固与思考。</p><h2 id="源码分析类结构"><a href="#源码分析类结构" class="headerlink" title="源码分析类结构"></a>源码分析类结构</h2><p>源码基于<code>jdk1.8</code>，首先来一段<code>ArrayList.java</code>类的介绍：</p><ol><li>代码总行数<code>1469</code>行；</li><li>实现了<code>AbstractList&lt;E&gt;</code>抽象类；</li><li>继承<code>List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</code>；</li></ol><h2 id="源码方法分类讲解"><a href="#源码方法分类讲解" class="headerlink" title="源码方法分类讲解"></a>源码方法分类讲解</h2><p>先看下这张图：</p><p><img src="http://mkstatic.lianbian.net/ArrayListPublicMethod.png" alt="ArrayList构造方法和公用方法"></p><p>有没有一下就懵了？不着急，我把这个类的方法<strong>分类</strong>一下：</p><p><img src="http://mkstatic.lianbian.net/ArrayListClass1.png" alt="方法分类点击查看大图"></p><p>这篇文章从<strong>继承、实现、属性、构造方法、常用方法</strong>（其他方法类不讲解）来分类讲解。</p><p>这里重复贴一下ArrayList类图。</p><p><img src="http://mkstatic.lianbian.net/ArrayList-20210811144456212-20210811190012060.png" alt="ArrayList类图"></p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过上边类图，你会发现ArrayList继承了<code>AbstractList</code>抽象类，AbstractList实现了List接口，而AbstractList抽象类有且只有一个抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br></code></pre></td></tr></table></figure><p>这里看源码的同学绝对有个疑问，为什么AbstractList实现了List接口，而我们的ArrayList也再次来实现了List，为什么会这样子设计呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>猜测有三：</strong></p><ol><li>增加可读性，不要套娃一样的去看源码，可以清晰看到类的主要实现接口；</li><li>兼容问题；</li><li>面向接口编程；</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>ArrayList实现了<code>List, RandomAccess, Cloneable, java.io.Serializable</code>接口；</p><p>ArrayList实现了List，提供了基础的添加、删除、遍历等操作；</p><p>ArrayList实现了RandomAccess，提供了随机访问的能力；</p><p>ArrayList实现了Cloneable，可以被克隆；</p><p>ArrayList实现了Serializable，可以被序列化；</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189L</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 默认容量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 空数组，如果传入的容量为0时使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 空数组，传传入容量时使用，添加第一个元素的时候会重新初始为默认容量大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 存储元素的数组</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 集合中元素的个数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br></code></pre></td></tr></table></figure><p><strong>serialVersionUID</strong> 是用来验证版本一致性的字段。我们将一个类的二进制字节序列转为java对象，也就是反序列化时，JVM会把传进来的二进制字节流中的serialVersionUID和本地相应的实体或对象的serialVersionUID进行比较，如果相同，则认为两个类是一致的，可以进行反序列化，否则就会出现版本不一致的反序列化异常。</p><p><strong>DEFAULT_CAPACITY</strong> 默认容量为10，也就是通过new ArrayList()创建时的默认容量。</p><p><strong>EMPTY_ELEMENTDATA</strong> 空的数组，这种是通过new ArrayList(0)创建时用的是这个空数组（下边构造方法代码中可以看到）。</p><p><strong>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</strong> 也是空数组，这种是通过new ArrayList()创建时用的是这个空数组，与EMPTY_ELEMENTDATA的区别是在添加第一个元素时使用这个空数组的会初始化为DEFAULT_CAPACITY（10）个元素。</p><p><strong>elementData</strong> 真正存放元素的地方，使用transient是为了不序列化这个字段，至于没有使用private修饰，后面注释是写的“为了简化嵌套类的访问”，但是楼主实测加了private嵌套类一样可以访问，private表示是类私有的属性，只要是在这个类内部都可以访问，<strong>嵌套类或者内部类也是在类的内部，所以也可以访问类的私有成员。</strong></p><p><strong>size</strong> 真正存储元素的个数，而不是elementData数组的长度（capacity）。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>ArrayList(int initialCapacity)构造方法</strong></p><p>传入初始容量，如果大于0就初始化elementData为对应大小，如果等于0就使用EMPTY_ELEMENTDATA空数组，如果小于0抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果传入的初始容量大于0，就新建一个数组存储元素</span><br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果传入的初始容量等于0，使用空数组EMPTY_ELEMENTDATA</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果传入的初始容量小于0，抛出异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span> + initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ArrayList()构造方法</strong></p><p>不传初始容量，初始化为DEFAULTCAPACITY_EMPTY_ELEMENTDATA空数组，会在添加第一个元素的时候扩容为默认的大小，即10。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 如果没有传入初始容量，则使用空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br>    <span class="hljs-comment">// 使用这个数组是在添加第一个元素的时候会扩容到默认大小10</span><br>    <span class="hljs-built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ArrayList(Collection&lt;? extends E&gt; c)构造方法</strong></p><p>传入集合并初始化elementData，这里会使用拷贝把传入集合的元素拷贝到elementData数组中，如果元素个数为0，则初始化为EMPTY_ELEMENTDATA空数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 把传入集合的元素初始化到ArrayList中</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 集合转数组</span><br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 检查c.toArray()返回的是不是Object[]类型，如果不是，重新拷贝成Object[].class类型</span><br><span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果c的空集合，则初始化为空数组EMPTY_ELEMENTDATA</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么<code>c.toArray();</code>返回的有可能不是Object[]类型呢？主要还是因为jdk自身的bug导致的。</p><p>源码注释：c.toArray might (incorrectly) not return Object[] (see 6260652)</p><p><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652</a></p><p>请看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Father[] fathers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>[]&#123;&#125;;<br>        <span class="hljs-comment">// 打印结果为class [Lcom.coolcoding.code.Son;</span><br>        System.out.println(fathers.getClass());<br><br>        List&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyList</span>();<br>        <span class="hljs-comment">// 打印结果为class [Ljava.lang.String;</span><br>        System.out.println(strList.toArray().getClass());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 子类重写父类的方法，返回值可以不一样</span><br><span class="hljs-comment">     * 但这里只能用数组类型，换成Object就不行</span><br><span class="hljs-comment">     * 应该算是java本身的bug</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] toArray() &#123;<br>        <span class="hljs-comment">// 为了方便举例直接写死</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用方法（增删改查）"><a href="#常用方法（增删改查）" class="headerlink" title="常用方法（增删改查）"></a>常用方法（增删改查）</h3><p><strong>add(E e)方法</strong></p><p>添加元素到末尾，平均时间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 检查是否需要扩容</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 把元素插入到最后一位</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果是空数组DEFAULTCAPACITY_EMPTY_ELEMENTDATA，就初始化为默认大小10</span><br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 扩容</span><br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 新容量为旧容量的1.5倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 如果新容量发现比需要的容量还小，则以需要的容量为准</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">// 如果新容量已经超过最大容量了，则使用最大容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// 以新容量拷贝出来一个新数组</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><ol><li>检查是否需要扩容；</li><li>如果elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA则初始化容量大小为DEFAULT_CAPACITY；</li><li>新容量是老容量的1.5倍（oldCapacity + (oldCapacity &gt;&gt; 1)），如果加了这么多容量发现比需要的容量还小，则以需要的容量为准；</li><li>创建新容量的数组并把老数组拷贝到新数组；</li></ol><p><strong>add(int index, E element)方法</strong></p><p>添加元素到指定位置，平均时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 检查是否越界</span><br>    rangeCheckForAdd(index);<br>    <span class="hljs-comment">// 检查是否需要扩容</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 将inex及其之后的元素往后挪一位，则index位置处就空出来了</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    <span class="hljs-comment">// 将元素插入到index的位置</span><br>    elementData[index] = element;<br>    <span class="hljs-comment">// 大小增1</span><br>    size++;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><ol><li>检查索引是否越界；</li><li>检查是否需要扩容；</li><li>把插入索引位置后的元素都往后挪一位；</li><li>在插入索引位置放置插入的元素；</li><li>大小加1；</li></ol><p><strong>remove(int index)方法</strong></p><p>删除指定索引位置的元素，时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 检查是否越界</span><br>    rangeCheck(index);<br><br>    modCount++;<br>    <span class="hljs-comment">// 获取index位置的元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <br>    <span class="hljs-comment">// 如果index不是最后一位，则将index之后的元素往前挪一位</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>    <br>    <span class="hljs-comment">// 将最后一个元素删除，帮助GC</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>    <span class="hljs-comment">// 返回旧值</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><ol><li>检查索引是否越界；</li><li>获取指定索引位置的元素；</li><li>如果删除的不是最后一位，则其它元素往前移一位；</li><li>将最后一位置为null，方便GC回收；</li><li>返回删除的元素。</li></ol><p>可以看到，ArrayList删除元素的时候并没有缩容。</p><p><strong>remove(Object o)方法</strong></p><p>删除指定元素值的元素，时间复杂度为O(n)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-comment">// 如果要删除的元素为null，则以null进行比较，使用==</span><br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 遍历整个数组，找到元素第一次出现的位置，并将其快速删除</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-comment">// 如果要删除的元素不为null，则进行比较，使用equals()方法</span><br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><p>循环调用fastRemove(int index)</p><p><strong>fastRemove(int index)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 少了一个越界的检查</span><br>    modCount++;<br>    <span class="hljs-comment">// 如果index不是最后一位，则将index之后的元素往前挪一位</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index, numMoved);<br>    <span class="hljs-comment">// 将最后一个元素删除，帮助GC</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><ol><li>找到第一个等于指定元素值的元素；</li><li>快速删除；</li></ol><p>fastRemove(int index)相对于remove(int index)少了检查索引越界的操作，可见jdk将性能优化到极致。</p><p><strong>set(int index, E element)方法</strong></p><p>修改指定元素值的元素，时间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>  <span class="hljs-comment">// 检查是否越界</span><br>rangeCheck(index);<br>  <br>  <span class="hljs-comment">// 获取index位置的元素</span><br>  <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>  <br>  <span class="hljs-comment">// 设置index位置的元素</span><br>  elementData[index] = element;<br>  <br>  <span class="hljs-comment">// 返回</span><br>  <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br><span class="hljs-keyword">if</span> (index &gt;= size)<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><ol><li>检查索引是否越界，这里只检查是否越上界，如果越上界抛出IndexOutOfBoundsException异常，如果越下界抛出的是ArrayIndexOutOfBoundsException异常。</li><li>获取指定索引的位置的元素，赋值给oldValue，用于返回</li><li>设置指定索引位置的元素</li><li>返回oldValue</li></ol><p><strong>get(int index)方法</strong></p><p>获取指定索引位置的元素，时间复杂度为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 检查是否越界</span><br>    rangeCheck(index);<br>    <span class="hljs-comment">// 返回数组index位置的元素</span><br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br><br>E <span class="hljs-title function_">elementData</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> (E) elementData[index];<br>&#125;<br></code></pre></td></tr></table></figure><p>步骤：</p><ol><li>检查索引是否越界，这里只检查是否越上界，如果越上界抛出IndexOutOfBoundsException异常，如果越下界抛出的是ArrayIndexOutOfBoundsException异常。</li><li>返回索引位置处的元素；</li></ol><h2 id="源码总结"><a href="#源码总结" class="headerlink" title="源码总结"></a>源码总结</h2><ol><li>ArrayList内部使用数组存储元素，当数组长度不够时进行扩容，每次加一半的空间，ArrayList不会进行缩容；</li><li>ArrayList支持随机访问，通过索引访问元素极快，时间复杂度为O(1)；</li><li>ArrayList添加元素到尾部极快，平均时间复杂度为O(1)；</li><li>ArrayList添加元素到中间比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li><li>ArrayList从尾部删除元素极快，时间复杂度为O(1)；</li><li>ArrayList从中间删除元素比较慢，因为要搬移元素，平均时间复杂度为O(n)；</li></ol><h2 id="面试题答案"><a href="#面试题答案" class="headerlink" title="面试题答案"></a>面试题答案</h2><p><strong>ArrayList的size和capacity怎么理解？</strong></p><p>如果把 ArrayList 看作一个杯子的话，capacity 就是杯子的容积，也就是代表杯子能装多少东西，而 size 就是杯子装的东西的体积。杯子可能装满了，也可能没装满，所以 capacity &gt;= size 。capacity 过大和过小都不好，过大会造成浪费，过小又存放不下多个元素的值，capacity == size，则 ArrayList 空间利用率最大，但是不利于添加新的元素。当 ArrayList 实例内的元素个数不再改变了，可以使用 trimToSize() 方法最小化 ArrayList 实例来节省空间，也即是使 capacity == size。</p><p><strong>ArrayList内部是怎么存放数据的？</strong></p><p>ArrayList 可以看做是数组的封装，使用 elementData 数组来存储数据，使用 size 来代表 elementData 的非 null 元素个数。elementData 前没有访问修饰符，所以只有同类和同包下的类可以直接方法，外界想要知道 ArrayList 实例内元素的个数就要通过 size 属性。elementData 数组类型是 Object 类型，可以存放任意的引用类型，不能存放基本的数据类型。</p><p><strong>ArrayList的大小是如何自动扩容的？</strong></p><p>扩容是发生在添加操作前的，要保证要添加元素在 elementData 数组中有位置，也即是 size 加上要添加的元素个数要小于 capacity（size + num &lt;= capacity 就说明容量是充足的），所以在添加方法中，先调用 ensureCapacityInternal(int) 方法来确保 elementData 容量充足，然后再进行具体的添加操作。如果 ensureCapacityInternal 方法（ensureCapacityInternal 方法中有调用了其他方法）发现数组容量不够了，就会扩容。扩容实际的方法是 grow(int) 方法，使用位运算符来使数组的容量扩容 1.5 倍。但是需要注意的是，没有指定初始化值的 ArrayList 实例，第一次扩容并不是以 1.5 倍扩容的，而是使用的默认容量 10，所以网上很多直接说 ArrayList 扩容是 1.5 倍也有不当之处，这点从 JDK 源码中可以很明确的看出来。</p><p>如果在构造 ArrayList 实例时，指定初始化值（初始化容量或者集合），那么就会创建指定大小的 Object 数组，并把该数组对象的引用赋值给 elementData；如果不指定初始化值，在第一次添加元素值时会使用默认的容量大小 10 作为 elementData 数组的初始容量，使用 Arrays.conpyOf() 方法创建一个 Object[10] 数组。</p><p><strong>在索引中ArrayList的增加或者删除某个对象的运行过程？效率很低吗？解释一下为什么？</strong></p><p>其实通过上边的源码可以知道，我们要分情况来讨论，详情见源码总结3、4、5、6点。</p><p><strong>ArrayList中的remove是如何操作的？</strong></p><p>见源码remove解析。</p><p><strong>ArrayList的add操作优化？</strong></p><p>核心就是避免 ArrayList 内部进行扩容。</p><p>​    1、对于普通少量的 add 操作，如果插入元素的个数已知，最好使用带初始化参数的构造方法，避免 ArrayList 内部再进行扩容，提高性能。</p><p>​    2、对于大量的 add 操作，最好先使用 ensureCapacity 方法来确保 elementData 数组中有充足的容量来存放我们后面 add 操作的元素，避免 ArrayList 实例内部进行扩容。上面提到的 ensureCapacityInternal 方法是一个私有方法，不能直接调用，而 ensureCapacity 方法是一个共有方法，专门提供给开发者使用的，提高大量 add 操作的性能。</p><p>我是连边，专注于Java和架构领域，坚持撰写有原理，有实战，有体系的技术文章。</p><p>可以关注<code>订阅号@连边</code>不错过精彩文章</p><p><img src="http://mkstatic.lianbian.net/202203082219869.jpg" alt="订阅号@连边"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java注解的原理与实战</title>
    <link href="/java/d1d8d45277af.html"/>
    <url>/java/d1d8d45277af.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每当我们在敲代码的时候，按下<code>@Data</code>，在<code>lombok</code>插件帮助下，就把繁琐的<code>get set</code>工作做得服服帖帖；而敲下 <code>@Test</code>，也能很方便的右键菜单运行我们的单元测试程序 …</p><p>你会不会觉得这些玩意儿，真神奇。</p><p>今天给大家讲的主角是<code>注解</code>。</p><p>注解，是Java中最重要的，但是却最容易被人<em><strong>遗忘</strong></em>的知识点。</p><p>很多时候，就理所当然的觉得它就一直是那样子的；</p><p>哪怕<code>Spring</code>、<code>SpringMVC</code>、<code>SpringBoot</code>等框架中充满了<code>注解</code>，还是选择性地忽视它。</p><p>很多时候，不明白它是怎么起作用的，甚至把它和 **注释 **混淆 …</p><p>我们在工作中机械性地在<code>Controller</code>上加 <code>@RequestMapping</code>。</p><p>想彻底弄清楚注解吗？</p><p>通过本文，<em><strong>循序渐进</strong></em>的彻底搞明白<em><strong>注解</strong></em>。</p><h1 id="为什么要有注解"><a href="#为什么要有注解" class="headerlink" title="为什么要有注解"></a>为什么要有注解</h1><p>如果早期用<code>xml bean</code>来配置来管理过类对象的相信有很深的感触，到项目的开发后期，开发人员都不知道什么时候开始，发现<code>xml</code>的维护越来越糟糕。</p><p>而使用注解，能够让配置与代码维持一个很好的平衡（不过份耦合也不过份松散），而且也能 <strong>提高我们代码的阅读性</strong>，比如我看到 <code>@Test</code>注解，会很自然的知道这个注解是用来做测试功能的；</p><p>还有一个潜在优势，就是和注解和注释一样，它的位置信息就能表示它的<strong>作用域</strong>；</p><p>例如下边这个<code>@Test</code> 注解，我们一看就知道在 <code>funUnit</code> 来作用，而实际也是如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> funUnit &#123;<br>   <span class="hljs-comment">// 这行注释给下边这行的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为有自定义注解的存在，所以也能方便我们扩展配置与功能；</p><p>所以呢，为什么我们需要注解，就是基于几点为初衷：</p><ol><li>让我们从繁琐的配置文件中抽离出来；</li><li>提高代码阅读性；</li><li>自定义注解能够方便我们扩展配置与功能；</li></ol><h1 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h1><p>引用维基百科的定义：</p><blockquote><p>Java注解又称Java标注，是JDK5.0版本开始支持加入源代码的特殊语法 <strong>元数据</strong> 。</p><p>Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。 当然它也支持自定义Java标注。</p></blockquote><p>连边的一句话定义：</p><blockquote><p>在指定的位置上放上一个记号，然后在这个记号的里边，可以有这个记号自己的属性，然后规定一些规则。（如：在什么地方可以放这个标记，在什么时候可以获取到这个标记。）</p></blockquote><p>暂时不理解这句话没事，我们先补充一些注解的基础知识。</p><h1 id="注解的语法"><a href="#注解的语法" class="headerlink" title="注解的语法"></a>注解的语法</h1><h2 id="注解分类"><a href="#注解分类" class="headerlink" title="注解分类"></a>注解分类</h2><ol><li>自定义注解：自己写的注解，如我之前那篇文章，自定义的 <code>@UserSiteMail、@PayCode</code> 注解；</li><li>JDK内置注解：如<code>@Override</code>检验方法重写，<code>@Deprecated</code>标识方法过期等</li><li>还有第三方框架提供的注解：SpringMVC的<code>@Controller</code></li></ol><h2 id="注解语法"><a href="#注解语法" class="headerlink" title="注解语法"></a>注解语法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention</span><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> 注解名称&#123;<br>    属性列表;<br>&#125;<br></code></pre></td></tr></table></figure><p>上边这段代码， 有两个<em><strong>元注解（注解的注解）</strong></em>，它属于<em><strong>JDK内置注解</strong></em></p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><figure class="highlight plaintext"><figcaption><span>：加在注解上，限定该注解能放的位置。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs @Target```"><br>```java<br>类或接口：ElementType.TYPE；<br>字段：ElementType.FIELD；<br>方法：ElementType.METHOD；<br>构造方法：ElementType.CONSTRUCTOR；<br>方法参数：ElementType.PARAMETER<br>  <br>定义多个：<br>@Target(&#123;<br>ElementType.METHOD,<br>  ElementType.FIELD<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>：用来规定注解的保留策略，就是在哪个阶段，我们需要保留我们定义的这些标记。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs @Retention```"><br>```java<br>SOURCE：在源码中保留，我们要保留标记，比如@Override，@FunctionalInterface，一般编译器语法检查的，都在源码级别保留；<br>ClASS：在class文件中保留注解，如果@Retention不存在，则该注解默认为CLASS；<br>RUNTIME：通常我们自定义的Annotation都是RUNTIME，因为我们一般应用注解都是在反射的时候来处理业务逻辑；<br></code></pre></td></tr></table></figure><p><img src="http://mkstatic.lianbian.net/v2-14ec3964feb69f2e8ed2dc4a2e90d6a2_720w.jpg" alt="保留策略（图片来源网络）"></p><h2 id="完整语法示例"><a href="#完整语法示例" class="headerlink" title="完整语法示例"></a>完整语法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 因为要通过反射处理业务，所以定义在运行时</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>  <br><span class="hljs-comment">// 类或者接口上使用</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> PayCode &#123;  <br><br>     String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;    <br>     String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;  <br>&#125;<br><br><span class="hljs-comment">// 使用的地方</span><br><span class="hljs-meta">@PayCode(value = &quot;alia&quot;, name = &quot;支付宝支付&quot;)</span>  <br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliaPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPay</span> &#123;  <br><br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;  <br>         System.out.println(<span class="hljs-string">&quot;===发起支付宝支付===&quot;</span>);  <br>     &#125;  <br>&#125;  <br><br> <br><span class="hljs-meta">@PayCode(value = &quot;weixin&quot;, name = &quot;微信支付&quot;)</span>  <br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeixinPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPay</span> &#123;  <br> <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;  <br>         System.out.println(<span class="hljs-string">&quot;===发起微信支付===&quot;</span>);  <br>     &#125;  <br>&#125; <br><br> <br><span class="hljs-meta">@PayCode(value = &quot;jingdong&quot;, name = &quot;京东支付&quot;)</span>  <br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JingDongPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPay</span> &#123;  <br> <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;===发起京东支付===&quot;</span>);  <br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>还记得前边连边定义的那句话吗？</p><blockquote><p>在指定的位置上放上一个记号，然后在这个记号的里边，可以有这个记号自己的属性，然后规定一些规则。（如：在什么地方可以放这个标记，在什么时候可以获取到这个标记。）</p></blockquote><p>嵌套到这个注解中来翻译一下：</p><p>我在各种支付方式的地方，放上一个记号，记号里设置自己的属性（alia、weixin、jingdong），在类或者接口上可以放这个记号（@Target(ElementType.TYPE)  ），这个标记在运行时的时候获取到（@Retention(RetentionPolicy.RUNTIME)  ）。</p><h1 id="注解的本质与原理"><a href="#注解的本质与原理" class="headerlink" title="注解的本质与原理"></a>注解的本质与原理</h1><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口，这里可以通过class文件看出；</p><p>查看class文件方式（简单的写一下步骤，不清楚的可以<code>google</code>）：</p><ol><li>IDEA左上角打开File—Project Structure</li><li>在Project Settings — Modules 下找到我们的项目</li><li>点击右侧的Paths ， 查看Output Path位置</li><li>复制路径，在我的电脑中粘贴路径即可找到对应文件夹</li><li><code>javap -v</code> 粘贴class文件路径</li></ol><p>查看上面<code>payCode</code>注解class文件如下：</p><p><img src="http://mkstatic.lianbian.net/image-20210803153300329.png" alt="payCode class文件"></p><p>美化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PayCode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>接口本质的具体实现类是<code>Java 运行时</code>生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象<code>$Proxy1</code>。通过代理对象调用自定义注解（接口）的方法，会最终调用<code>AnnotationInvocationHandler</code> 的<code>invoke</code>方法。该方法会从<code>memberValues</code> 这个Map 中索引出对应的值。而<code>memberValues</code> 的来源是Java 常量池。</p><h1 id="注解实战"><a href="#注解实战" class="headerlink" title="注解实战"></a>注解实战</h1><p>这里贴上我上一篇文章（）里边的项目实战，利用注解，优雅的避免了冗长的 <code>if..else...</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PayCode(value = &quot;alia&quot;, name = &quot;支付宝支付&quot;)</span>  <br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliaPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPay</span> &#123;  <br><br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;  <br>         System.out.println(<span class="hljs-string">&quot;===发起支付宝支付===&quot;</span>);  <br>     &#125;  <br>&#125;  <br><br> <br><span class="hljs-meta">@PayCode(value = &quot;weixin&quot;, name = &quot;微信支付&quot;)</span>  <br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeixinPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPay</span> &#123;  <br> <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;  <br>         System.out.println(<span class="hljs-string">&quot;===发起微信支付===&quot;</span>);  <br>     &#125;  <br>&#125; <br><br> <br><span class="hljs-meta">@PayCode(value = &quot;jingdong&quot;, name = &quot;京东支付&quot;)</span>  <br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JingDongPay</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPay</span> &#123;  <br> <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">()</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;===发起京东支付===&quot;</span>);  <br>     &#125;  <br>&#125;<br><br><span class="hljs-meta">@Service</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PayService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;  <br> <br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, IPay&gt; payMap = <span class="hljs-literal">null</span>;  <br>     <br>     <span class="hljs-meta">@Override</span>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent contextRefreshedEvent)</span> &#123;  <br>         <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> contextRefreshedEvent.getApplicationContext();  <br>         Map&lt;String, Object&gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode.class);  <br>        <br>         <span class="hljs-keyword">if</span> (beansWithAnnotation.size &gt; <span class="hljs-number">0</span>) &#123;  <br>             payMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();  <br>             beansWithAnnotation.forEach((key, value) -&gt;&#123;  <br>                 <span class="hljs-type">String</span> <span class="hljs-variable">bizType</span> <span class="hljs-operator">=</span> value.getClass().getAnnotation(PayCode.class).value();  <br>                 payMap.put(bizType, (IPay) value);  <br>             &#125;);  <br>         &#125;  <br>     &#125;  <br>    <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(String code)</span> &#123;  <br>        payMap.get(code).pay();  <br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm问题故障分析</title>
    <link href="/java/44ff81bc6b75.html"/>
    <url>/java/44ff81bc6b75.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>jar能正常启动，但是到下午四点的时候，系统就会变得缓慢，需要重启服务才能恢复访问，cpu和内存占用都不高。</p><p>spring启动注册的bean被销毁了。</p><h2 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h2><p>最近我们系统做了什么改动？</p><p>原来稳定的系统，为什么会突然变得不稳定。查看代码，看看是否有嫌疑代码，没有找到，再想有什么改动 … 想到了最近做的服务化部署，经过一番查看，找到了原因。</p><p>黑窗口启动：<code>xxx-jar-start.bat</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">```<br><br>服务化后的启动参数xml（粗心导致的）<br><br>```xml<br></code></pre></td></tr></table></figure><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><ol><li>虚拟机类型</li><li>分代收集理论设计</li><li>jvm内存模型</li><li>搞清楚jvm几个参数含义</li><li>32位Java默认启动参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 简单参数</span></span><br>[root@localhost ~]# java -XX:+PrintCommandLineFlags -version<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 详细参数</span></span><br>[root@localhost ~]# java -XX:+PrintFlagsFinal -version<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 过滤参数</span></span><br>[root@localhost ~]# java -XX:+PrintFlagsFinal -version | grep MaxHeapSize<br></code></pre></td></tr></table></figure><ol start="6"><li>复现问题</li><li>jvm内存分布情况</li><li>增加GC日志</li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java jam</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
